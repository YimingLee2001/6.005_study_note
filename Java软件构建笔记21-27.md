[TOC]

# Reading 21: Sockets & Networking（套接字和网络通讯）

## Client/server design pattern（客户端/服务器设计模式）

在这篇阅读中（以及问题集中），我们探讨了**客户端/服务器设计模式**，用于与消息传递进行通信。

在此模式中，有两种类型的进程：客户端和服务器。 客户端通过连接到服务器来启动通信。 客户端向服务器发送请求，服务器发回回复。 最后，客户端断开连接。 服务器可能同时处理来自多个客户端的连接，客户端也可能连接到多个服务器。

许多 Internet 应用程序都以这种方式工作：Web 浏览器是 Web 服务器的客户端，像 Outlook 这样的电子邮件程序是邮件服务器的客户端，等等。

在互联网上，客户端和服务器进程通常在不同的机器上运行，仅通过网络连接，但事实并非如此——服务器可以是与客户在同一台机器上运行的进程。

## Network sockets（网络套接字）

### IP 地址（IP address）

网络接口由 [IP 地址 ](https://en.wikipedia.org/wiki/IP_address)标识。 IPv4 地址是 32 位数字，写在四个 8 位部分中。 例如（在撰写本文时）：

* `173.194.123.40`是 Google Web 服务器的地址。
* `127.0.0.1`是环回地址或 localhost 地址：它始终引用本地计算机。从技术上讲，第一个八位字节为`127`的任何地址都是环回地址，但`127.0.0.1`属于标准地址。

您可以[向 Google 询问您当前的 IP 地址 ](https://www.google.com/search?q=my+ip)。 一般来说，当您随身携带笔记本电脑时，每次将机器连接到网络时，都可以为其分配一个新的 IP 地址。

### 主机名（Hostname）

[主机名](https://en.wikipedia.org/wiki/Hostname)是可以转换为 IP 地址的名称。 单个主机名可以在不同时间映射到不同的 IP 地址;多个主机名可以映射到同一 IP 地址。 例如：

* `web.mit.edu`是 MIT 的 Web 服务器的名称。可以使用在命令行中使用`dig`、`host`或`nslookup`将名称转化为 IP 地址，例如：

  ```powershell
  PS C:\Users\Yiming> nslookup bupt.edu.cn
  服务器:  UnKnown
  Address:  182.254.116.116
  
  名称:    bupt.edu.cn
  ```

* `google.com`正是你所想的那样。 尝试使用上述命令之一查找`google.com`的 IP 地址。 你看到了什么？

  ```powershell
  PS C:\Users\Yiming> nslookup google.com
  服务器:  UnKnown
  Address:  182.254.116.116
  
  非权威应答:
  名称:    google.com
  Address:  142.250.217.78
  ```

* `localhost`是`127.0.0.1`的名称。 当您想与在自己的计算机上运行的服务器进行通信时，请与`localhost`通信。

从主机名到 IP 地址的转换是[域名系统（DNS）](https://en.wikipedia.org/wiki/Domain_Name_System)的工作。 这非常酷，但不是我们今天讨论的一部分。

### 端口号（Port number）

一台机器可能有多个客户端希望连接到的服务器应用程序，因此我们需要一种方法将同一网络接口上的流量定向到不同的进程。

网络接口有多个[端口](https://en.wikipedia.org/wiki/Port_(computer_networking))，这些端口由从 0（保留的，因此我们实际上从 1 开始）到 65535 的 16 位数字标识。

服务器进程绑定到特定端口 — 它现在正在**侦听**该端口。 客户端必须知道服务器正在侦听的端口号。 有一些[已知的端口](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports)是为系统级进程保留的，并为某些服务提供标准端口。 例如：

- 端口 22 是标准的 SSH 端口。 当您使用 SSH 进行连接时，软件会自动使用端口 22。
- 端口 25 是标准电子邮件服务器端口。
- 端口 80 是标准的 Web 服务器端口。 当您在 Web 浏览器中连接到 URL 时，它会连接到端口 80。

当端口不是标准端口时，它被指定为地址的一部分。 例如，URL 引用计算机上的端口 9000。

当客户端连接到服务器时，该传出连接还使用客户端网络接口上的端口号，该端口号通常是从可用的非已知端口中随机选择的。

### 网络套接字（Network socket）

[**套接字** ](https://en.wikipedia.org/wiki/Network_socket)表示客户端和服务器之间连接的一端。

- 服务器进程使用**侦听套接字（listening socket）**来等待来自远程客户端的连接。

  在 Java 中，使用[`ServerSocket`](https://docs.oracle.com/javase/8/docs/api/?java/net/ServerSocket.html)制作一个监听套接字，并使用其[`accept`](https://docs.oracle.com/javase/8/docs/api/java/net/ServerSocket.html#accept--)方法来监听它。

- **连接的套接字**可以向连接另一端的进程发送和接收消息。 它由本地 IP 地址和端口号以及远程地址和端口来标识，这使服务器能够区分来自不同 IP 的并发连接，或来自不同远程端口上的同一 IP 的并发连接。

  在 Java 中，客户端使用[`Socket`](https://docs.oracle.com/javase/8/docs/api/?java/net/Socket.html)构造函数来建立与服务器的套接字连接。 服务器获取连接的套接字作为从`ServerSocket.accept`返回的` Socket`对象。

## I/O 接口

### 缓冲区（Buffer）

客户端和服务器通过网络交换的数据是以块的形式发送的。 这些很少只是字节大小的块，尽管它们可能是。 发送端（发送请求的客户端或发送响应的服务器）通常会写入一大块（可能是像“HELLO， WORLD！”这样的完整字符串，或者可能是 20 兆字节的视频数据）。 网络将这些数据包切成数据包，每个数据包都通过网络单独路由。 在另一端，接收器将数据包重新组装成字节流。

结果是一种突发式的数据传输——当你想要读取它们时，数据可能已经存在，或者你可能不得不等待它们到达并被重新组装。

当数据到达时，它们会进入**缓冲区** ，这是一个内存中的数组，用于保存数据直到您读取它。

### 流（Stream）

进入或流出套接字的数据是字节[**流** ](https://en.wikipedia.org/wiki/Stream_(computing))。

在 Java 中， [`InputStream`](https://docs.oracle.com/javase/8/docs/api/?java/io/InputStream.html)对象表示流入程序的数据源。 例如：

- 使用 [`FileInputStream`](https://docs.oracle.com/javase/8/docs/api/?java/io/FileInputStream.html)从磁盘上的文件读取
- 来自 [`System.in`](https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#in)的用户输入
- 从网络套接字输入

[`OutputStream`](https://docs.oracle.com/javase/8/docs/api/?java/io/OutputStream.html)对象表示数据接收器，即我们可以将数据写入到的位置。 例如：

- [`FileOutputStream`](https://docs.oracle.com/javase/8/docs/api/?java/io/FileOutputStream.html)，用于保存到文件
- [`System.out`](https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#out)是一个[ `PrintStream`](https://docs.oracle.com/javase/8/docs/api/?java/io/PrintStream.html)，一个`OutputStream`打印各种类型的可读表示
- 输出到网络套接字

对于套接字，请记住，一个进程的输出是另一个进程的输入。如果 Alice 和 Bob 具有套接字连接，则 Alice 有一个输出流，该输出流流到 Bob 的输入流，*反之亦然*。

阅读以下关于流的内容，[IO - I/O 流 - 《Java 编程要点（Essential Java）》 - 书栈网 · BookStack](https://www.bookstack.cn/read/essential-java/docs-IO Streams.md)

## 阻塞（Blocking）

**阻塞**意味着线程等待（不做进一步的工作）直到事件发生。 我们可以用这个术语来描述方法和方法调用：如果一个方法是**阻塞方法**，那么对该方法的调用可以**阻塞**，等到某个事件发生后再返回给调用者。

套接字输入/输出流表现出阻塞行为：

- 当传入套接字的缓冲区为空时，调用`read`会阻塞数据，直到数据可用。
- 当目标套接字的缓冲区已满时，调用`write`会阻塞，直到空间可用。

从程序员的角度来看，阻塞非常方便，因为无论数据到达的时间如何，程序员都可以编写代码，就好像`read` （或`write`）调用将始终工作一样。如果缓冲区中已有数据（可能为`write`、space），则调用可能会很快返回。 但是，如果读取或写入无法成功，则调用将**阻塞** 。 操作系统会处理将该线程延迟到`read`或`write`成功之前的细节。

阻塞发生在并发编程过程中，而不仅仅是在 [I/O ](https://en.wikipedia.org/wiki/Input/output)中（进出进程的通信，可能通过网络，或与文件之间的通信，或与命令行或 GUI 上的用户通信……并发模块不像顺序程序那样同步工作，因此当需要协调操作时，它们通常必须等待彼此赶上。

我们将在下一篇文章中看到，这种等待导致了并发编程中的第二种主要错误（第一种是竞争条件）：**死锁**，其中模块正在等待彼此做某事，因此它们都无法取得任何进展。 但那是下次的事了。

## 使用网络套接字

阅读以下关于套接字的内容，[网络编程 - Socket - 《Java 编程要点（Essential Java）》 - 书栈网 · BookStack](https://www.bookstack.cn/read/essential-java/docs-socket.md)

这个例子使用一种我们从未见过的语法：[try-with-resources ](https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html)语句。 此语句的格式为：

```java
try (
    // create new objects here that require cleanup after being used,
    // and assign them to variables
) {
    // code here runs with those variables
    // cleanup happens automatically after the code completes
} catch(...) {
    // you can include catch clauses if the code might throw exceptions
}
```

需要注意的点是，服务器将需要一个新线程来处理每个新客户端的 I/O。注意在 Java 使用匿名的`Runnable`来完成。

## 传输协议（Wire protocols）

现在我们已经将客户端和服务器与套接字连接起来，它们通过这些套接字来回传递什么？

**协议**是一组消息，可以由两个通信方交换。 特别是**传输协议**是一组表示为字节序列的消息，如`Hello world`和`Bye`（假设我们已经就将这些字符编码为字节的方法达成一致）。

大多数 Internet 应用程序都使用基于 ASCII 的简单有线协议。 您可以使用名为 Telnet 的程序来检查它们。 例如：

### HTTP协议

[超文本传输协议 （HTTP） ](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)是万维网的语言。 我们已经知道端口 80 是向 Web 服务器发送 HTTP 的众所周知的端口，因此让我们在命令行上与一个端谈。

您将在问题集上使用 Telnet，因此请立即尝试这些。 用户输入以**绿色**显示，对于 telnet 连接的输入，换行符（按回车键）显示为 **↵** ：

```powershell
$ telnet www.eecs.mit.edu 80
Trying 18.62.0.96...
Connected to eecsweb.mit.edu.
Escape character is '^]'.
GET /↵
<!DOCTYPE html>
... lots of output ...
<title>Homepage | MIT EECS</title>
... lots more output ...
```

`GET`命令获取一个网页。`/`是您希望在网站上看到的页面的路径。 因此，此命令将在`http://www.eecs.mit.edu:80/`处获取页面。 由于 80 是 HTTP 的默认端口，因此这相当于在 Web 浏览器中访问 [http://www.eecs.mit.edu/](https://www.eecs.mit.edu/)。 结果是浏览器呈现的 HTML 代码，以显示 EECS 主页。

互联网协议由[RFC规范 ](https://en.wikipedia.org/wiki/Request_for_Comments)定义（RFC代表“征求意见”，一些RFC最终被采纳为标准）。[ RFC 1945 ](https://tools.ietf.org/html/rfc1945)定义了 HTTP 版本 1.0，并在 [RFC 2616 ](https://tools.ietf.org/html/rfc2616)中被 HTTP 1.1 取代。 因此，对于许多网站来说，如果你想和他们交谈，你可能需要说HTTP 1.1。 例如：

```powershell
$ telnet web.mit.edu 80
Trying 18.9.22.69...
Connected to web.mit.edu.
Escape character is '^]'.
GET /aboutmit/ HTTP/1.1↵
Host: web.mit.edu↵
↵
HTTP/1.1 200 OK
Date: Tue, 31 Mar 2015 15:14:22 GMT
... more headers ...

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
... more HTML ...
<title>MIT — About</title>
... lots more HTML ...
```

这一次，您的请求必须以空行结尾。 HTTP 版本 1.1 要求客户端在请求中指定一些额外的信息（称为标头），空行表示标头的结束。

您也很可能会发现 telnet 在发出此请求后不会退出 - 这一次，服务器保持连接打开，因此您可以立即发出另一个请求。 要手动退出 Telnet，请键入转义字符（可能是`Ctrl`-`]`）以显示提示，然后键入`quit`：

```powershell
... lots more HTML ...
</html>
Ctrl-]↵
telnet> quit↵
Connection closed.
```

### SMTP协议

[简单邮件传输协议（SMTP）](https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol)是发送电子邮件的协议（从收件箱检索电子邮件的客户端程序使用不同的协议）。 由于电子邮件系统是在垃圾邮件出现之前设计的，因此现代电子邮件通信充满了旨在防止滥用的陷阱和启发式方法。 但我们仍然可以尝试说 SMTP。 回想一下，众所周知的 SMTP 端口是 25。

您需要填写 *your-IP-address-here* 和 *your-username-here* ，为了清楚起见，↵ 表示换行符。 这只有在您使用 MITnet 时才有效，即便如此，您的邮件也可能因看起来可疑而被拒绝：

```powershell
$ telnet dmz-mailsec-scanner-4.mit.edu 25
Trying 18.9.25.15...
Connected to dmz-mailsec-scanner-4.mit.edu.
Escape character is '^]'.
220 dmz-mailsec-scanner-4.mit.edu ESMTP Symantec Messaging Gateway
HELO your-IP-address-here↵
250 2.0.0 dmz-mailsec-scanner-4.mit.edu says HELO to your-ip-address:port
MAIL FROM: <your-username-here@mit.edu>↵
250 2.0.0 MAIL FROM accepted
RCPT TO: <your-username-here@mit.edu>↵
250 2.0.0 RCPT TO accepted
DATA↵
354 3.0.0 continue.  finished with "\r\n.\r\n"
From: <your-username-here@mit.edu>↵
To: <your-username-here@mit.edu>↵
Subject: testing↵
This is a hand-crafted artisanal email.↵
.↵
250 2.0.0 OK 99/00-11111-22222222
QUIT↵
221 2.3.0 dmz-mailsec-scanner-4.mit.edu closing connection
Connection closed by foreign host.
```

### 设计传输协议

在设计有线协议时，应用用于设计抽象数据类型操作的相同经验法则：

- 保持不同消息的数量**较小** 。 最好是有一些可以组合的命令和响应，而不是许多复杂的消息。
- 每条消息都应该有一个明确定义的目的和**连贯**的行为。
- 消息集必须**足以**让客户端发出他们需要发出的请求，并且让服务器能够传递结果。

正如我们要求表示独立于我们的类型一样，我们应该在我们的协议中实现**平台独立**性。 HTTP 可以由任何 Web 服务器和任何操作系统上的任何 Web 浏览器使用。 该协议没有说明网页如何存储在磁盘上，服务器如何准备或生成网页，客户端将使用什么算法来呈现它们，等等。

[**序列化**](https://en.wikipedia.org/wiki/Serialization)是将内存中的数据结构转换为可以轻松存储或传输的格式的过程（与 [*Thread Safety* 的可序列化性 ](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/20-thread-safety/#serializability)不同）。与其发明一种新的格式来在客户端和服务器之间序列化数据，不如使用现有的格式。例如，[JSON（JavaScript 对象表示法）](https://en.wikipedia.org/wiki/JSON)是一种简单、广泛使用的格式，用于序列化基本值、数组和带有字符串键的映射。

### 指定线路协议

为了精确定义客户端和服务器允许哪些消息，请使用语法。

例如，以下是 [RFC 2616 第 5 节 ](https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html)中 HTTP 1.1 请求语法的一小部分：

```powershell
request ::= request-line
            ((general-header | request-header | entity-header) CRLF)*
            CRLF
            message-body?
request-line ::= method SPACE request-uri SPACE http-version CRLF
method ::= "OPTIONS" | "GET" | "HEAD" | "POST" | ...
...
```

使用语法，我们可以看到在前面的这个示例请求中：

```powershell
GET /aboutmit/ HTTP/1.1
Host: web.mit.edu
```

## 测试客户端/服务器代码

请记住，[并发性很难测试和调试](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/19-concurrency/#concurrency_is_hard_to_test_and_debug)。 我们无法可靠地再现竞争条件，而网络增加了完全超出我们控制范围的延迟源。 您需要进行并发性设计，并仔细论证代码的正确性。

### 将网络代码与数据结构和算法分离

客户端/服务器程序中的大多数 ADT 不需要依赖网络。 确保将它们指定、测试和实施为单独的组件，这些组件不会出现错误、易于理解并准备好更改 - 部分原因是它们不涉及任何网络代码。

如果需要从多个线程并发使用这些 ADT（例如，处理不同客户端连接的线程），我们的下一篇文章将讨论您的选项。 否则，请使用上一讲中的限制、不可变性和现有线程安全数据类型的线程安全策略。

### 将套接字代码与流代码分开

需要从套接字读取和写入套接字的函数或模块可能只需要访问输入/输出流，而不需要访问套接字本身。 此设计允许您通过将模块连接到不是来自套接字的流来测试模块。

两个有用的Java类是 [`ByteArrayInputStream`](https://docs.oracle.com/javase/8/docs/api/?java/io/ByteArrayInputStream.html)和 [`ByteArrayOutputStream`](https://docs.oracle.com/javase/8/docs/api/?java/io/ByteArrayOutputStream.html)。假设我们想测试这个方法：

```java
void upperCaseLine(BufferedReader input, PrintWriter output) throws IOException
  requires: input and output are open
  effects: attempts to read a line from input
           and attempts to write that line, in upper case, to output
```

该方法通常与套接字一起使用：

```java
Socket sock = ...

// read a stream of characters from the socket input stream
BufferedReader in = new BufferedReader(new InputStreamReader(sock.getInputStream()));
// write characters to the socket output stream
PrintWriter out = new PrintWriter(sock.getOutputStream(), true);

upperCaseLine(in, out);
```

如果大小写转换是我们实现的函数，那么它应该已经单独指定、测试和实现。 但现在我们还可以测试以下的`upperCaseLine`读/写行为：

```java
// fixed input stream of "dog" (line 1) and "cat" (line 2)
String inString = "dog\ncat\n";
ByteArrayInputStream inBytes = new ByteArrayInputStream(inString.getBytes());
ByteArrayOutputStream outBytes = new ByteArrayOutputStream();

// read a stream of characters from the fixed input string
BufferedReader in = new BufferedReader(new InputStreamReader(inBytes));
// write characters to temporary storage
PrintWriter out = new PrintWriter(outBytes, true);

upperCaseLine(in, out);

// check that it read the expected amount of input
assertEquals("expected input line 2 remaining", "cat", in.readLine());
// check that it wrote the expected output
assertEquals("expected upper case of input line 1", "DOG\n", outBytes.toString());
```

在此测试中，`inBytes`和`outBytes`是[**桩测试**](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/03-testing/#unit_testing_and_stubs)。 为了隔离和测试`upperCaseLine`，我们用满足相同规格但具有预设行为的组件替换它通常依赖的组件（来自套接字的输入/输出流）：具有固定输入的输入流，以及将输出存储在内存中的输出流。

针对更复杂模块的测试策略可能会使用**模拟对象**来模拟真实客户端或服务器的行为，方法是生成整个预设的交互序列，并断言从其他组件接收的每条消息的正确性。

# Reading 22: Queues and Message-Passing（队列和消息传递）

## 两种并发模型（Twe models for concurrency）

- 在**共享内存**模型中，并发模块通过在内存中读取和写入共享的可变对象进行交互。 在单个 Java 进程中创建多个线程是共享内存并发的主要示例。
- 在**消息传递**模型中，并发模块通过通信通道相互发送不可变消息进行交互。 到目前为止，我们有一个消息传递的例子：[客户端/服务器模式](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/21-sockets-networking/#clientserver_design_pattern)，其中客户端和服务器是并发进程，通常在不同的机器上，通信通道是[网络套接字](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/21-sockets-networking/#network_sockets)。

共享内容通过**可变数据**的**隐式**修改来实现交互，而消息队列通过**不可变对象**的传递来实现**显式**交互。因此，消息队列更安全。

我们将在本文中讨论如何在单个进程内实现消息传递，而不是通过网络在进程之间实现消息传递。 我们将使用**阻塞队列** （一种现有的线程安全类型）来实现进程内线程之间的消息传递。

## 使用线程传递消息

我们之前讨论过进程之间的消息传递：[客户端和服务器通过网络套接字进行通信](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/21-sockets-networking/#network_sockets)。 我们还可以在同一进程内的线程之间使用消息传递，这种设计通常比带有锁的共享内存设计更可取，我们将在下次阅读中讨论。

使用同步队列在线程之间传递消息。 队列在客户端/服务器消息传递中提供与缓冲网络通信通道相同的功能。 Java 为具有阻塞操作的队列提供了[`BlockingQueue`](https://docs.oracle.com/javase/8/docs/api/?java/util/concurrent/BlockingQueue.html)接口：

在普通`Queue`中：

* `add(e)`将元素`e`添加到队列的末尾。
* `remove()`删除并返回队列头部的元素。如果队列为空，则引发异常。

`BlockingQueue`扩展了此接口：

> 此外，还支持在检索元素时等待队列变为非空，并在存储元素时等待队列中的空间变为可用的操作。

* `put(e)`会引发阻塞，直到它可以将元素`e`添加到队列的末尾（若队列没有大小限制，则`put`不会阻塞）。
* `take()`会引发阻塞，直到它可以删除并返回队列头部的元素，也就是会等待直到队列不为空。

当您使用`BlockingQueue`来完成线程之间的消息传递时，请确保使用`put()`和`take()`操作，而不是`add()`和`remove()`。

类似于通过网络传递消息的客户端/服务器模式是线程之间传递消息的**生产者-消费者设计模式**。 生产者线程和消费者线程共享一个同步队列。 生产者将数据或请求放入队列中，消费者删除并处理它们。 一个或多个生产者和一个或多个使用者可能都在同一队列中添加和删除项目。 此队列对于并发性必须是安全的。

Java 为`BlockingQueue`提供了两种实现：

* `ArrayBlockingQueue`是一个使用数组表示形式的固定大小的队列。 如果队列已满，则`put`在队列中添加新项目将会阻塞。
* `LinkedBlockingQueue`是一个使用链接列表表示形式的可增长队列。 如果未指定最大容量，则队列将永远不会填满，因此`put`永远不会阻塞。

与套接字发送和接收的字节流不同，这些同步队列（如 Java 中的普通集合类）可以保存任意类型的对象。 我们必须为队列中的消息选择或设计一种类型，而不是设计有线协议。 **它必须是不可变的类型。** 正如我们在线程安全 ADT 或有线协议中的消息上执行操作一样，我们必须在此处设计消息，以防止争用条件并使客户端能够执行他们需要的原子操作。

## 使用队列实现消息传递

您可以在 GitHub 上查看此示例的所有代码：[**squarer example**](https://github.com/mit6005/sp16-ex22-square)。

下面是一个用于平方整数的消息传递模块：

```java
/** Squares integers. */
public class Squarer {

    private final BlockingQueue<Integer> in;
    private final BlockingQueue<SquareResult> out;
    // Rep invariant: in, out != null

    /** Make a new squarer.
     *  @param requests queue to receive requests from
     *  @param replies queue to send replies to */
    public Squarer(BlockingQueue<Integer> requests,
                   BlockingQueue<SquareResult> replies) {
        this.in = requests;
        this.out = replies;
    }

    /** Start handling squaring requests. */
    public void start() {
        new Thread(new Runnable() {
            public void run() {
                while (true) {
                    // TODO: we may want a way to stop the thread
                    try {
                        // block until a request arrives
                        int x = in.take();
                        // compute the answer and send it back
                        int y = x * x;
                        out.put(new SquareResult(x, y));
                    } catch (InterruptedException ie) {
                        ie.printStackTrace();
                    }
                }
            }
        }).start();
    }
}
```

`Squarer`传入的消息是整数；平方器知道它的工作是对这些数字进行平方，因此不需要进一步的细节。

传出消息是以下`SquareResult`实例：

```java
/** An immutable squaring result message. */
public class SquareResult {
    private final int input;
    private final int output;

    /** Make a new result message.
     *  @param input input number
     *  @param output square of input */
    public SquareResult(int input, int output) {
        this.input = input;
        this.output = output;
    }

    @Override public String toString() {
        return input + "^2 = " + output;
    }
}
```

我们可能会对`SquareResult`添加额外的观察者，以便客户端可以检索输入数字和输出结果。

最后，这是一个使用平方器的主要方法：

```java
public static void main(String[] args) {

    BlockingQueue<Integer> requests = new LinkedBlockingQueue<>();
    BlockingQueue<SquareResult> replies = new LinkedBlockingQueue<>();

    Squarer squarer = new Squarer(requests, replies);
    squarer.start();

    try {
        // make a request
        requests.put(42);
        // ... maybe do something concurrently ...
        // read the reply
        System.out.println(replies.take());
    } catch (InterruptedException ie) {
        ie.printStackTrace();
    }
}
```

我们不应该感到惊讶，此代码与用于实现使用套接字传递的消息的代码非常相似。

## 停止

如果我们想关闭`Squarer`，这样它就不再等待新的输入了怎么办？ 在客户端/服务器模型中，如果我们希望客户端或服务器停止监听我们的消息，我们就会关闭套接字。 如果我们希望客户端或服务器完全停止，我们可以退出该进程。 但在这里，平方只是*同一*进程中的另一个线程，我们不能“关闭”一个队列。

一种策略是**特殊消息** ：队列上的特殊消息，向该消息的使用者发出结束其工作的信号。 要关闭平方器，因为它的输入消息只是整数，我们必须选择一个神奇的毒药整数（每个人都知道 0 的平方是 0，对吧？没有人需要要求 0 的平方...）或使用 null（不要使用 null）。 相反，我们可能会将请求队列上的元素类型更改为 ADT：

```java
SquareRequest = IntegerRequest + StopRequest
```

操作：

```java
input : SquareRequest → int
shouldStop : SquareRequest → boolean
```

当我们想停止平方器时，我们将使用`StopRequest`，其中`shouldStop` 返回 `true`。

例如，在`Squarer.start()`：

```java
public void run() {
    while (true) {
        try {
            // block until a request arrives
            SquareRequest req = in.take();
            // see if we should stop
            if (req.shouldStop()) { break; }
            // compute the answer and send it back
            int x = req.input();
            int y = x * x;
            out.put(new SquareResult(x, y));
        } catch (InterruptedException ie) {
            ie.printStackTrace();
        }
    }
}
```

也可以通过调用`interrupt()`方法来中断线程。 如果线程在等待中被阻塞，它被阻塞的方法将抛出一个`InterruptedException`（这就是为什么我们几乎每次调用阻塞方法时都必须尝试捕获该异常）。如果线程没有被阻塞，则将设置一个中断标志。线程必须检查此标志，以查看它是否应该停止工作。 例如：

```java
public void run() {
    // handle requests until we are interrupted
    while ( ! Thread.interrupted()) {
        try {
            // block until a request arrives
            int x = in.take();
            // compute the answer and send it back
            int y = x * x;
            out.put(new SquareResult(x, y));
        } catch (InterruptedException ie) {
            // stop
            break;
        }
    }
}
```

## 消息传递的线程安全参数

带有消息传递的线程安全参数可能依赖于：

- 同步队列的**现有线程安全数据类型**。 这个队列肯定是共享的，而且肯定是可变的，所以我们必须确保它对于并发是安全的。
- 多个线程可能同时访问的消息或数据的**不可变性**。
- 将数据**限制**在单个生产者/消费者线程中。 一个生产者或使用者使用的局部变量对其他线程不可见，这些线程仅使用队列中的消息相互通信。
- **限制**通过队列发送的可变消息或数据，但一次只能由一个线程访问。 这一论点必须仔细阐述和实施。 但是，如果一个模块在将某些可变数据（如烫手山芋）放入队列以传递给另一个线程时立即删除对它们的所有引用，则一次只有一个线程可以访问这些数据，从而排除并发访问。

与同步相比，消息传递可以使并发系统中的每个模块更容易维护自己的线程安全不变性。 如果数据是使用线程安全的通信通道在模块之间传输的，则我们不必考虑多个线程访问共享数据。

# Reading 23: Locks and Synchronization（锁和同步）

我们之前对**线程安全**定义为：在多个线程中使用时行为正确，无论这些线程如何执行，无需额外的协调。

这是一般原则： **concurrent program 的正确性不应取决于 accidents of timing** 。

为了实现这种正确性，我们列举了四种使代码对并发安全的策略：

1. 封闭性（Confinement）：不在线程之间共享数据。
2. 不可变性（Immutability）：使共享数据不可变。
3. 使用现存的线程安全数据类型：使用为您执行协调的数据类型。
4. 同步（Synchronization）：防止线程同时访问共享数据。 这就是我们用来实现线程安全类型的方法，但当时我们没有讨论它。

## 同步

**并发程序的正确性不应取决于时间的意外。**

由于并发操作共享可变数据导致的竞争条件是灾难性的错误 — 难以发现、难以重现、难以调试 — 我们需要一种方法让共享内存的并发模块彼此**同步**。

**锁**是一种同步技术。 锁是一种抽象，一次最多允许一个线程拥有它。 **持有锁**是一个线程告诉其他线程的方式：“我正在更改这个东西，现在不要碰它。

锁有两个操作：

- **`acquire`**允许线程获取锁的所有权。 如果一个线程尝试获取另一个线程当前拥有的锁，它将*阻塞*，直到另一个线程释放该锁。 此时，它将与尝试获取锁的任何其他线程争用。 一次最多有一个线程可以拥有该锁。
- **`release`**放弃对锁的所有权，允许另一个线程获得它的所有权。

使用 lock 还可以告诉编译器和处理器您正在同时使用共享内存，因此 registers 和 caches 将被刷新到共享存储。 这避免了 [reordering ](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/19-concurrency/#reordering)的问题 ，确保锁的所有者始终查看最新数据。

## 死锁

如果使用得当和小心，锁可以防止竞争条件。但随后另一个问题又出现了。因为使用锁需要线程等待（当另一个线程持有锁时`acquire`阻塞），所以可能会陷入两个线程**相互等待**的情况 - 因此两者都无法取得进展。

## 开发线程安全的抽象数据类型

让我们看看如何使用同步来实现线程安全的 ADT。

您可以在 GitHub 上查看此示例的所有代码： [**edit buffer example** ](https://github.com/mit6005/sp16-ex23-editor)。 *您不需要*阅读和理解所有代码。 所有相关部分摘录如下。

假设我们正在构建一个多用户编辑器，例如 Google Docs，它允许多人连接到它并同时编辑它。 我们需要一个可变数据类型来表示文档中的文本。 这是界面；基本上，它表示一个带有 INSERT 和 DELETE 操作的字符串：

```java
/** An EditBuffer represents a threadsafe mutable
 *  string of characters in a text editor. */
public interface EditBuffer {
    /**
     * Modifies this by inserting a string.
     * @param pos position to insert at
                      (requires 0 <= pos <= current buffer length)
     * @param ins string to insert
     */
    public void insert(int pos, String ins);

    /**
     * Modifies this by deleting a substring
     * @param pos starting position of substring to delete 
     *                (requires 0 <= pos <= current buffer length)
     * @param len length of substring to delete 
     *                (requires 0 <= len <= current buffer length - pos)
     */
    public void delete(int pos, int len);

    /**
     * @return length of text sequence in this edit buffer
     */
    public int length();

    /**
     * @return content of this edit buffer
     */
    public String toString();
}
```

此数据类型的一个非常简单的 rep 只是一个字符串：

```java
public class SimpleBuffer implements EditBuffer {
    private String text;
    // Rep invariant: 
    //   text != null
    // Abstraction function: 
    //   represents the sequence text[0],...,text[text.length()-1]
```

这个 rep 的缺点是每次我们执行 insert 或 delete 时，我们都必须将整个字符串复制到新字符串中。 这会变得昂贵。 我们可以使用的另一个 rep 是字符数组，末尾有空格。 如果用户只是在文档末尾键入新文本（我们不必复制任何内容），这很好，但是如果用户在文档开头键入，那么我们每次击键都会复制整个文档。

许多文本编辑器在实践中使用的更有趣的代表称为 *gap buffer* 。 它基本上是一个包含额外空间的字符数组，但额外的空间不是在末尾包含所有额外空间，而是可以出现在缓冲区中任何位置的*间隙*。 每当需要执行 insert 或 delete 操作时，数据类型首先将间隙移动到操作的位置，然后执行 insert 或 delete。 如果间隙已经存在，则无需复制任何内容 — 插入只会占用部分间隙，而删除只会扩大间隙！ 间隙缓冲区特别适合表示用户使用光标编辑的字符串，因为插入和删除往往集中在光标周围，因此间隙很少移动。

```java
/** GapBuffer is a non-threadsafe EditBuffer that is optimized
 *  for editing with a cursor, which tends to make a sequence of
 *  inserts and deletes at the same place in the buffer. */
public class GapBuffer implements EditBuffer {
    private char[] a;
    private int gapStart;
    private int gapLength;
    // Rep invariant: 
    //   a != null
    //   0 <= gapStart <= a.length
    //   0 <= gapLength <= a.length - gapStart
    // Abstraction function: 
    //   represents the sequence a[0],...,a[gapStart-1],
    //                           a[gapStart+gapLength],...,a[length-1]
```

在多用户方案中，我们需要多个间隙，每个用户的光标一个，但现在我们将使用单个间隙。

### 开发数据类型的步骤

回想一下我们设计和实现 ADT 的秘诀：

1. **指定。** 定义操作（方法签名和规范）。 我们在界面中做到了这一点。` EditBuffer`
2. **测试。** 开发操作测试用例。 请参阅提供的代码中的`EditBufferTest`。 该测试套件包括一个基于对操作的参数空间进行分区的测试策略。
3. **代表。** 选择代表。 我们选择了其中两个用于`EditBuffer` ，这通常是一个好主意：
   1. **首先实施一个简单的暴力代表。** 它更容易编写，你更有可能把它写对，它会验证你的测试用例和你的规范，这样你就可以在继续更难的实现之前解决其中的问题。 这就是为什么我们在继续`SimpleBuffer`之前先实施`SimpleBuffer`的原因。 也不要扔掉你的简单版本——把它留在身边，这样你就可以测试和比较一些东西，以防更复杂的版本出现问题。
   2. **记下 rep invariant 和 abstraction 函数，并实现 `checkRep（） `。** 在每个 constructor、producer 和 mutator 方法的末尾使用`checkRep()`断言 rep invariant。 （通常没有必要在 observer 结束时调用它，因为 rep 没有改变。 事实上，断言对于测试复杂的实现非常有用，因此在复杂方法的末尾也断言后置条件并不是一个坏主意。 您将在代码`GapBuffer.moveGap()`中看到一个示例，其中包含此读数。

在所有这些步骤中，我们首先是完全单线程的。 当我们编写规范和选择 rep 时，多线程客户端应该始终在我们的脑海中（我们稍后会看到，可能需要仔细选择操作，以避免数据类型的客户端中出现争用条件）。 但首先要在顺序的单线程环境中让它工作并进行全面测试。

现在我们已准备好进行下一步：

4. **同步。** 论证您的代表是线程安全的。 在类中将其显式地作为注释写下来，就在 rep 不变量旁边，这样维护者就知道你是如何在类中设计线程安全的。

阅读的这一部分是关于如何执行第 4 步的。 我们已经看到了[如何制作 thread safety argument](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/20-thread-safety/#how_to_make_a_safety_argument)，但是这一次，我们将在该参数中依赖同步措施。

然后是我们上面暗示的额外步骤：

5. **迭代** . 你可能会发现，你选择的操作使得编写具有客户端所需保证的线程安全类型变得困难。 您可能会在步骤 1 中、编写测试时在步骤 2 中或实现时在步骤 3 或 4 中发现这一点。 如果是这种情况，请返回并优化 ADT 提供的操作集。

## 锁

锁非常常用，因此 Java 将它们作为内置语言功能提供。

在 Java 中，每个对象都有一个隐式关联的锁 — `String`、数组、`ArrayList`，并且您创建的每个类，它们的所有对象实例都有一个锁。 即使是最基础的`Object`也有锁，所以`Object`经常被用于显式锁：

```java
Object lock = new Object();
```

但是，您不能调用 Java 内部锁的`acquire`和`release`。 相反，您可以使用**`synchronized`**语句在块的持续时间内获取锁：

```java
synchronized (lock) { // thread blocks here until lock is free
    // now this thread has the lock
    balance = balance + 1;
    // exiting the block releases the lock
}
```

像这样的同步区域提供**突变例外**：一次只有一个线程可以位于由给定对象的锁保护的同步区域中。 换句话说，您回到了顺序编程世界，一次只有一个线程运行，至少对于引用同一对象的其他同步区域而言是这样。

### 锁保护对数据的访问

锁用于**保护**共享数据变量，如此处所示的账户余额。 如果对数据变量的所有访问都由同一个锁对象保护（被同步块包围），那么这些访问将保证是原子的——不会被其他线程中断。

因为 Java 中的每个对象都有一个隐式关联的锁，所以您可能会认为只拥有一个对象的锁会阻止其他线程访问该对象。 **事实并非如此。** 使用`obj`获取与对象关联的锁

```java
synchronized (obj) { ... }
```

在线程 t 中，它做并且也只做这一件事：阻止其他线程进入`synchronized(obj)`模块，直到线程 t 完成了它的同步模块。这就是实际情况。

锁仅提供与获取相同锁的其他线程的互斥。 对 data 变量的所有访问都必须由同一锁保护。 您可以在单个锁后面保护整个变量集合，但所有模块必须就它们都将获取和释放的锁达成一致。

## 监视器模式（Monitor pattern）

当你在编写类的方法时，最方便的锁是对象实例本身，即`this`。作为一种简单的方法，我们可以通过将对 rep 的所有访问包装在`synchronized(this)`

```java
/** SimpleBuffer is a threadsafe EditBuffer with a simple rep. */
public class SimpleBuffer implements EditBuffer {
    private String text;
    ...
    public SimpleBuffer() {
        synchronized (this) {
            text = "";
            checkRep();
        }
    }
    public void insert(int pos, String ins) {
        synchronized (this) {
            text = text.substring(0, pos) + ins + text.substring(pos);
            checkRep();
        }
    }
    public void delete(int pos, int len) {
        synchronized (this) {
            text = text.substring(0, pos) + text.substring(pos+len);
            checkRep();
        }
    }
    public int length() {
        synchronized (this) {
            return text.length();
        }
    }
    public String toString() {
        synchronized (this) {
            return text;
        }
    }
}
```

请注意这里非常仔细的纪律。触及代表的每种方法都必须用锁保护 — 即使是像`length()`和`toString()`这样明显小而微不足道的方法。 这是因为读操作和写操作都必须被保护 — 如果读操作没有被保护，那么他们可能能够看到处于部分修改状态的 rep。

此方法称为**监视器模式**。 监视器是一个类，其方法是互斥的，因此一次只能有一个线程位于该类的实例内。

Java 为监视器模式提供了一些语法糖。 如果将关键字`synchronized`添加到方法签名中，则 Java 将充当围绕方法主体编写`synchronized(this)`的样式。 所以下面的代码是实现同步`SimpleBuffer`的一种等价方法：

```java
/** SimpleBuffer is a threadsafe EditBuffer with a simple rep. */
public class SimpleBuffer implements EditBuffer {
    private String text;
    ...
    public SimpleBuffer() {
        text = "";
        checkRep();
    }
    public synchronized void insert(int pos, String ins) {
        text = text.substring(0, pos) + ins + text.substring(pos);
        checkRep();
    }
    public synchronized void delete(int pos, int len) {
        text = text.substring(0, pos) + text.substring(pos+len);
        checkRep();
    }
    public synchronized int length() {
        return text.length();
    }
    public synchronized String toString() {
        return text;
    }
}
```

请注意，`SimpleBuffer`构造函数没有`synchronized`关键字。 Java 实际上在语法上禁止这样做，因为正在构造的对象应被限制在单个线程中，直到它从其构造函数返回。 因此，同步构造函数应该是不必要的。

## 具有同步的线程安全论证

现在我们用锁保护了`SimpleBuffer`的 rep，我们可以编写一个更好的线程安全论证：

```java
/** SimpleBuffer is a threadsafe EditBuffer with a simple rep. */
public class SimpleBuffer implements EditBuffer {
    private String text;
    // Rep invariant: 
    //   text != null
    // Abstraction function: 
    //   represents the sequence text[0],...,text[text.length()-1]
    // Thread safety argument:
    //   all accesses to text happen within SimpleBuffer methods,
    //   which are all guarded by SimpleBuffer's lock
```

如果我们使用监视器模式来同步它的所有方法，则相同的参数适用于`GapBuffer`。

请注意，类的封装，没有 rep 暴露，对于提出这个论点非常重要。 如果文本是公开的：

```java
public String text;
```

然后，外部客户端的`SimpleBuffer`将能够读取和写入它，而无需知道它们应该首先获取锁，并且`SimpleBuffer`不再是线程安全的。

### 锁定规则

锁定规则是一种确保同步代码是线程安全的策略。我们必须满足两个条件：

1. 每个共享的可变变量都必须由一些锁保护。除非在获取该锁的同步块内，否则不能读取或写入数据。
2. 如果一个变量涉及多个共享的可变变量（甚至可能位于不同的对象中），那么所有涉及的变量都必须由*同一个*锁保护。 线程获取锁后，必须在释放锁之前重新建立不变量。

此处使用的监视器模式满足这两个规则。 rep 中所有共享的可变数据 — rep 不变量所依赖的 — 都由同一个锁保护。

## 原子操作

考虑对`EditBuffer`数据类型执行查找和替换操作：

```java
/** Modifies buf by replacing the first occurrence of s with t.
 *  If s not found in buf, then has no effect.
 *  @returns true if and only if a replacement was made
 */
public static boolean findReplace(EditBuffer buf, String s, String t) {
    int i = buf.toString().indexOf(s);
    if (i == -1) {
        return false;
    }
    buf.delete(i, s.length());
    buf.insert(i, t);
    return true;
}
```

此方法对`buf` — 将其转换为字符串以便搜索`s`、 删除旧文本，然后在其位置插入`t`，进行三次不同的调用。 即使这些调用中的每一个都是原子的，但整个`findReplace`方法并不是线程安全的，因为其他线程可能会在`findReplace`工作时改变缓冲区，从而导致它删除错误的区域或将替换放回错误的位置。

为了阻止这种事，`findReplace`需要与其余所有客户端的`buf`同步。

### 授予客户端对锁的访问权限

有时，将数据类型的锁提供给客户端很有用，以便它们可以使用它来使用数据类型实现更高级别的原子操作。

因此，解决`findReplace`问题的一种方法是记录 Client 端可以使用`EditBuffers`的锁来相互同步：

```java
/** An EditBuffer represents a threadsafe mutable string of characters
 *  in a text editor. Clients may synchronize with each other using the
 *  EditBuffer object itself. */
public interface EditBuffer {
   ...
}
```

之后`findReplace`就可以在`buf`上同步：

```java
public static boolean findReplace(EditBuffer buf, String s, String t) {
    synchronized (buf) {
        int i = buf.toString().indexOf(s);
        if (i == -1) {
            return false;
        }
        buf.delete(i, s.length());
        buf.insert(i, t);
        return true;
    }
}
```

这样做的效果是将监视器模式已经围绕各个`toString`、`delete`和`insert`方法放置的同步区域扩大到单个原子区域，以确保所有三种方法的执行都不会受到其他线程的干扰。

## 把`synchronized`关键字搞得到处都是？

（这一小节讨论的是，使用包裹住整个方法的`synchronized`关键字，还是使用需要要保持同步的具体数据类型的`synchronized()`块）

那么，线程安全是否只是将`synchronized`关键字放在程序中的每个方法上呢？ 很遗憾，不是。

首先，您实际上并不想随意同步方法。 同步会给您的程序带来很大的成本。 进行同步方法调用可能需要更长的时间，因为需要获取锁（并刷新缓存并与其他处理器通信）。 正是出于这些性能原因，Java 默认使其许多可变数据类型保持不同步状态。 当您不需要同步时，请不要使用它。

以更深思熟虑的方式使用`synchronized`的另一个论点是，尽可能最大限度减少了对锁的访问范围。把`synchronized`添加到每一个方法上，意味着你的锁就是对象本身，并且每个引用你的对象的 Client 端都自动有一个对你的锁的引用，它可以随意获取和释放。因此，您的线程安全机制是公开的，可能会受到客户端的干扰。 相比之下，使用作为代表内部对象的锁，并使用`synchronized()`块适当且谨慎地获得。

最后，到处撒上`synchronized`是不够的。 不假思索地把`synchronized`丢到一个方法上意味着你正在获取一个锁，而不考虑它是哪个锁，或者它是否是保护你将要执行的共享数据访问的正确锁。 假设我们尝试通过简单地在声明中加入`synchronized`来解决`findReplace`的同步问题：

```java
public static synchronized boolean findReplace(EditBuffer buf, ...) {
```

这不会达到我们的预期效果。 它确实会获取一个锁 — 因为`findReplace`是一个静态方法，所以它会为`findReplace`恰好所在的整个类获取一个静态锁，而不是一个实例对象锁。 因此，一次只能有一个线程调用`findReplace` — 即使其他线程想要在*不同的*缓冲区上操作（这应该是安全的），它们仍然会被阻塞，直到单个锁被释放。 因此，我们将遭受性能的重大损失，因为一次只允许我们的大型多用户编辑器的一个用户进行查找和替换，即使他们都在编辑不同的文档。

然而，更糟糕的是，它不会提供有用的保护，因为其他触及文档的代码可能不会获得相同的锁。 它实际上不会消除我们的争用条件。

`synchronized`关键词不是万能的。 线程安全需要一条规则 — 使用限制、不变性或锁来保护共享数据。 而且这个规则需要写下来，否则维护者不会知道它是什么。

## 为并发设计数据类型

`findReplace`的问题可以用另一种方式来解释：接口对多个并发客户端真的不是那么友好。 它依赖于整数索引来指定插入和删除位置，这对其他赋值修改来说非常脆弱。 如果其他人在索引位置之前插入或删除，则索引将无效。

因此，如果我们设计专门用于并发系统的数据类型，我们需要考虑在交错时提供具有更好定义语义的操作。 例如，最好将`EditBuffer`与表示缓冲区中光标位置的数据类型`Position`配对，甚至与表示所选范围的数据类型`Selection`配对。 一旦获得，`Position`就可以保持它在文本中的位置，以防止周围的插入和删除，直到客户端准备好使用`Position`。 如果其他线程删除了`Position`周围的所有文本，那么`Position`将能够通知后续客户端发生了什么（可能有一个异常），并允许客户端决定做什么。 在为并发设计数据类型时，这些类型的考虑因素会发挥作用。

再举一个例子，考虑 Java 中的 [`ConcurrentMap`](https://docs.oracle.com/javase/8/docs/api/?java/util/concurrent/ConcurrentMap.html)接口。 此接口扩展了现有`Map`接口，添加了一些通常作为共享可变 map 上的原子操作的关键方法，例如：

- `map.putIfAbsent(key,value)`是原子操作版本的
  `if ( ! map.containsKey(key)) map.put(key, value);`
- `map.replace(key, value)`是原子操作版本的
  `if (map.containsKey(key)) map.put(key, value);`

## 死锁问题抬头

线程安全的锁定方法很强大，但（与限制和不可变性不同）它在程序中引入了阻塞。 线程有时必须等待其他线程退出同步区域，然后才能继续。 阻塞会增加死锁的可能性 — 这是一个非常真实的风险，坦率地*说，在*此设置中，它比使用阻塞 I/O 传递消息（我们第一次提到的地方）更常见。

使用锁定时，当线程同时获取多个锁时，会发生死锁，并且两个线程在持有每个线程都在等待另一个释放的锁时最终被阻塞。 不幸的是，监视器模式使这变得相当容易。 下面是一个示例。

假设我们正在对一系列书籍的社交网络进行建模：

```java
public class Wizard {
    private final String name;
    private final Set<Wizard> friends;
    // Rep invariant:
    //    name, friends != null
    //    friend links are bidirectional: 
    //        for all f in friends, f.friends contains this
    // Concurrency argument:
    //    threadsafe by monitor pattern: all accesses to rep 
    //    are guarded by this object's lock

    public Wizard(String name) {
        this.name = name;
        this.friends = new HashSet<Wizard>();
    }

    public synchronized boolean isFriendsWith(Wizard that) {
        return this.friends.contains(that);
    }

    public synchronized void friend(Wizard that) {
        if (friends.add(that)) {
            that.friend(this);
        } 
    }

    public synchronized void defriend(Wizard that) {
        if (friends.remove(that)) {
            that.defriend(this);
        } 
    }
}
```

与 Facebook 一样，这个社交网络是双向的：如果 *x* 是 *y* 的朋友，那么 *y* 就是 *x* 的朋友。`friend()`方法和`defriend()`方法通过修改两个对象的 rep 来强制执行该不变量，因为它们使用监视器模式，这意味着也要获取两个对象的锁。

让我们创建几个向导：

```java
    Wizard harry = new Wizard("Harry Potter");
    Wizard snape = new Wizard("Severus Snape");
```

然后考虑当两个独立的线程重复运行时会发生什么：

```java
    // thread A                   // thread B
    harry.friend(snape);          snape.friend(harry);
    harry.defriend(snape);        snape.defriend(harry);
```

我们很快就会陷入死锁。

问题的本质是获取多个锁，并在等待另一个锁空闲时持有一些锁。

请注意，线程 A 和线程 B 可以交错，这样就不会发生死锁：也许线程 A 在线程 B 有足够的时间获取第一个锁之前就获取并释放了这两个锁。 如果死锁中涉及的锁也涉及争用条件（而且很多时候是这样），那么死锁将同样难以重现或调试。

### 死锁解决方案 1：锁排序

防止死锁的一种方法是对需要同时获取的锁进行排序，并确保所有代码都按该序列获取锁。

在我们的社交网络示例中，我们可能总是按向导名称的字母顺序获取` Wizard`对象的锁。 由于线程 A 和线程 B 都需要 Harry 和 Snape 的锁，因此它们都将按以下顺序获取它们：首先是 Harry 的锁，然后是 Snape 的锁。 如果线程 A 在 B 之前获得 Harry 的锁，那么它也会在 B 之前获得 Snape 的锁，因为在 A 再次释放 Harry 的锁之前，B 无法继续。锁的排序会强制对获取它们的线程进行排序，因此无法在 waiting-for 图中生成循环。

代码可能如下所示：

```java
    public void friend(Wizard that) {
        Wizard first, second;
        if (this.name.compareTo(that.name) < 0) {
            first = this; second = that;
        } else {
            first = that; second = this;
        }
        synchronized (first) {
            synchronized (second) {
                if (friends.add(that)) {
                    that.friend(this);
                } 
            }
        }
    }
```

（请注意，按人名的字母顺序排序锁的决定对本书来说效果很好，但在现实生活中的社交网络中则行不通。 为什么不呢？ 什么比名称更适合用于锁排序呢？）（个人回答，现实中用户会改名，所以唯一 ID 更合适。）

尽管锁排序很有用（尤其是在 os 内核等代码中），但它在实践中也有许多缺点。

* 首先，它不是模块化的 — 代码必须知道系统中的所有锁，或者至少知道其子系统中的所有锁。
* 其次，代码可能很难或不可能在获得第一个锁之前确切地知道它需要哪些锁。 它可能需要做一些计算来弄清楚。 例如，考虑在社交网络图上进行深度优先搜索 — 在开始查找节点之前，您如何知道哪些节点需要锁定？

### 死锁解决方案 2：粗粒度锁定

比锁排序更常见的方法，特别是对于应用程序编程（与操作系统或设备驱动程序编程相反），是使用更粗略的锁定 - 使用单个锁来保护许多对象实例，甚至是程序的整个子系统。

例如，我们可能有一个用于整个社交网络的锁，并且其任何组成部分上的所有操作都在该锁上同步。 在下面的代码中，所有`Wizard`都属于`Castle`，我们只使用该`Castle`对象的 lock 进行同步：

```java
public class Wizard {
    private final Castle castle;
    private final String name;
    private final Set<Wizard> friends;
    ...
    public void friend(Wizard that) {
        synchronized (castle) {
            if (this.friends.add(that)) {
                that.friend(this);
            }
        }
    }
}
```

粗粒度的锁可能会显著降低性能。 如果你用一个锁保护一大堆可变数据，那么你就放弃了并发访问任何这些数据的能力。 在最坏的情况下，使用单个锁保护所有内容，您的程序可能基本上是连续的 — 一次只允许一个线程进行进度。

## 并发项目设计的目标

现在是弹出一个关卡并查看我们正在做什么的好时机。 回想一下，我们的主要目标是创建**不受错误影响** 、 **易于理解** 并**准备好更改** 的软件。

构建并发软件显然是实现所有这三个目标的挑战。 我们可以将问题分为两大类。 当我们询问并发程序是否免受 bug 的影响时，我们关心两个属性：

- **安全。** 并发程序是否满足其不变量及其规范？ 访问可变数据的竞赛威胁着安全。 安全提出了一个问题：你能证明**一些坏事永远不会发生** 吗？
- **活动性。** 程序是继续运行并最终执行您想要的操作，还是卡在某个地方永远等待永远不会发生的事件？ 你能证明**一些好事最终会发生** 吗？

死锁威胁活动性。活动性可能还需要**公平性** ，这意味着并发模块被赋予处理能力以推进其计算。 公平性主要取决于操作系统的线程调度程序，但您可以通过设置线程优先级来影响它（无论好坏）。

## 实践中的并发性

实际程序通常遵循哪些策略？

- **库数据结构**要么不使用同步（为单线程客户端提供高性能，同时将其留给多线程客户端以在顶部添加锁定）要么使用监视器模式。
- **具有许多部分的可变数据结构**通常使用粗粒度锁定或线程限制。 大多数图形用户界面工具包都遵循其中一种方法，因为图形用户界面基本上是一个由可变对象组成的大可变树。 Java Swing 是图形用户界面工具包，它使用线程限制。 只允许一个专用线程访问 Swing 的树。 其他线程必须将消息传递给该专用线程才能访问树。
- **搜索**通常使用不可变的数据类型。 我们的[布尔公式 satisfiability 搜索](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/16-recursive-data-types/recursive/#another_example_boolean_formulas)很容易实现多线程，因为涉及的所有数据类型都是不可变的。 不会有 race 或 deadlock 的风险。
- **操作系统**通常使用细粒度锁来获得高性能，并使用锁排序来处理死锁问题。

我们省略了一种重要的可变共享数据方法，因为它超出了本课程的范围，但值得一提的是： **数据库** 。 数据库系统广泛用于分布式客户端/服务器系统，如 Web 应用程序。 数据库使用**事务**避免了争用条件，这与同步区域类似，因为它们的效果是原子的，但它们不必获取锁，尽管如果事实证明发生了争用，事务可能会失败并回滚。 数据库还可以管理锁，并自动处理锁顺序。 有关如何在系统设计中使用数据库的更多信息，强烈建议使用 6.170 Software Studio;有关数据库内部工作原理的更多信息，请参阅 6.814 数据库系统。

如果您对并发程序的**性能**感兴趣 — 因为性能通常是我们首先向系统添加并发性的原因之一 — 那么 6.172 性能工程就是适合您的课程。

## 总结

生成一个没有错误、易于理解并准备好更改的并发程序需要仔细思考。 Heisenbug 会在您尝试固定它们后立即溜走，因此调试根本不是实现正确线程安全代码的有效方法。 线程可以以多种不同的方式交错它们的操作，以至于你永远无法测试所有可能的执行中的一小部分。

- 对数据类型进行线程安全参数，并在代码中记录它们。
- 获取锁允许线程对该锁保护的数据拥有独占访问权限，从而强制其他线程阻塞 — 只要这些线程也试图获取相同的锁。
- *监视器模式*使用每个方法获取的单个锁来保护数据类型的 rep。
- 获取多个锁导致的阻塞可能会产生死锁。

# Reading 24: Graphical User Interfaces（图形用户界面）

## View Tree（视图树）

图形用户界面由视图对象组成，每个视图对象占据屏幕的某个部分，通常是一个称为其边界框的矩形区域。视图概念在各种 UI 工具包中有多种名称。

<img src="C:\Users\Yiming\Documents\课程相关\自学\assets\view-tree-screenshot.png" alt="带有标记" style="zoom: 67%;" />

<img src="C:\Users\Yiming\Documents\课程相关\自学\assets\view-tree-snapshot.png" alt="视图树的快照图" style="zoom:67%;" />

这引出了我们今天要讨论的第一个重要模式：视图树。视图被安排到一个包含层次结构中，其中某些视图包含其他视图。典型的容器是窗口、面板和工具栏。视图树不仅仅是一个任意的层次结构，而且实际上是一个空间层次结构：子视图嵌套在其父视图的边界框内。

## 如何使用视图树

实际上，每个 GUI 系统都有某种类型的视图树。视图树是一个强大的结构思想，在典型的 GUI 中加载了职责：

**输出** 。视图负责显示自身，而视图树指导显示过程。GUI 通过改变视图树来更改其输出。例如，要在相册 GUI 中显示一组新的照片，将从视图树中删除当前缩略图，并在其位置添加一组新的缩略图。GUI 工具包中内置的重绘算法会自动重绘子树的受影响部分。在 Java Swing 中，树中的每个视图都有一个知道如何在屏幕上绘制自身的`paint()`方法。重绘过程是通过在树的根调用`paint()`来驱动的，该根以递归方式向下调用视图树的所有后代节点的调用`paint()`方法。

**输入** 。视图可以具有输入处理程序，视图树控制如何处理鼠标和键盘输入。稍后会详细介绍。

**布局** .视图树控制视图在屏幕上的布局方式，即如何分配其边界框。自动布局算法会自动计算视图的位置和大小。专用容器（如`JSplitPane`，`JScollPane`）会自行布局。更通用的容器 （`JPanel`，`JFrame`） 将布局决策委托给布局管理器（例如`GroupLayout`、`BorderLayout`、`BoxLayout`、…）。

## 输入处理

在 GUI 中处理 Input 的方式与我们在 parser 和 server 中处理 Input 的方式略有不同。在这些系统中，我们看到了一个解析器，它剥离了输入并决定如何将其定向到程序的不同模块。如果 GUI 是这样编写的，它可能看起来像这样（在伪代码中）：

```java
while (true) {
    read mouse click
    if (clicked on Thrash button) doThrash();
    else if (clicked on textbox) doPlaceCursor();
    else if (clicked on a name in the listbox) doSelectItem();
    ...
}
```

在 GUI 中，我们不会直接编写这种方法，因为它不是**模块化**的——它将按钮、列表框和文本框的职责混合在一个地方。相反，GUI 还利用视图树提供的空间分离来提供功能分离。鼠标单击和键盘事件分布在视图树周围，具体取决于它们发生的位置。

GUI 输入事件处理是**监听者模式** （也称为**发布/订阅**）的一个实例。在监听者模式中：

- 事件源生成离散事件流，这些事件对应于源中的状态转换。
- 一个或多个监听者注册对事件流的兴趣 （订阅），从而提供在发生新事件时要调用的函数。

在这种情况下，鼠标是事件源，事件是鼠标状态的变化：它的 x，y 位置或按钮的状态（无论它们是按下还是释放）。事件通常包括有关过渡的附加信息（例如鼠标的 x，y 位置），这些信息可以捆绑到事件对象中或作为参数传递。

当事件发生时，事件源通过调用其回调方法将其分发给所有订阅的侦听器。

通过图形用户界面的控制流如下所示：

- 顶级事件循环从鼠标和键盘读取输入。在 Java Swing 和大多数图形用户界面工具包中，此循环实际上是隐藏的。它被埋在工具包中，侦听器似乎被神奇地调用了。
- 对于每个输入事件，它会在树中找到正确的视图（通过查看鼠标的 x，y 位置）并将事件发送到该视图的侦听器。
- 每个监听者都执行其操作（这可能涉及例如修改视图树中的对象），然后立即返回到**事件循环**。

最后一部分 — 监听者尽快返回到事件循环 — 非常重要，因为它保留了用户界面的响应能力。我们将在稍后的阅读中回到这个问题。

模式不仅用于鼠标单击和键盘按键等低级输入事件。许多 GUI 对象生成自己的更高级别的事件，通常是低级别输入事件的某种组合的结果。例如：

- `JButton`在按下 action 事件时发送 action 事件（无论是通过鼠标还是键盘）
- `JList`在所选元素更改时发送 Selection 事件（无论是通过鼠标还是通过键盘）
- `JTextField`当其中的文本因任何原因更改时发送 change 事件

可以通过鼠标 （鼠标按下和鼠标松开事件） 或键盘 （这对于无法使用鼠标的用户（如盲人用户）非常重要） 来按下按钮。因此，您应该始终监听这些高级事件，而不是低级输入事件。使用`ActionListener`响应按下，而不是鼠标侦听器`JButton`按下。

## 将前端与后端分离

我们已经了解了 GUI 程序是如何围绕视图树构建的，以及如何通过将监听者附加到视图来处理输入事件。这是关注点分离的开始 - 输出由视图处理，输入由监听者处理。

但我们仍然缺少应用程序本身 — 表示用户界面显示和编辑的数据和逻辑的后端。（为什么我们要将其与用户界面分开？）

**Model-View-Controller 模式（ MVC 模式）**将这种关注点分离作为其主要目标。它将用户界面前端与应用程序后端分开，方法是将后端代码放入模型中，将前端代码放入视图和控制器中。MVC 还将输入与输出分开;控制器应该处理输入，而试图应该处理输出。

<img src="C:\Users\Yiming\Documents\课程相关\自学\assets\mvc.png" alt="模型-视图-控制器模式" style="zoom: 50%;" />

**Model** 负责维护特定于应用程序的数据并提供对该数据的访问权限。模型通常是可变的，它们提供了安全地更改状态的方法，保留了其表示的不变量。好的，所有可变对象都这样做。但是，当其数据发生更改时，模型还必须通知其客户端，以便从属视图可以更新其显示，并且从属控制器可以做出适当的响应。模型使用监听者模式执行此通知，其中感兴趣的视图和控制器将自己注册为模型生成的更改事件的侦听器。

**View** 对象负责输出。视图通常占据屏幕的某个块，通常是矩形区域。基本上，视图查询模型以获取数据并在屏幕上绘制数据。它监听模型中的更改，以便可以更新屏幕以反映这些更改。

**Controller** 处理输入。它接收键盘和鼠标事件，并指示模型进行相应的更改。

MVC 模式的一个简单示例是文本字段。右图显示了 Java Swing 的文本字段，称为`JTextField`。它的模型是一个可变的字符串。视图是在屏幕上绘制文本的对象（通常周围有一个矩形，以指示它是一个可编辑的文本字段）。控制器是一个对象，它接收用户键入的击键并将其插入到可变字符串中。

<img src="C:\Users\Yiming\Documents\课程相关\自学\assets\mvc-textfield.png" alt="模型-视图-控制器模式，如 JTextField 中所示" style="zoom:50%;" />

MVC 模式的实例在 GUI 软件中以多种比例出现。在更高级别上，此文本字段可能是视图（如地址簿编辑器）的一部分，不同的控制器为不同的模型（如地址簿）侦听它（对于文本更改事件）。但是，当您向下钻取到较低级别时，文本字段本身就是 MVC 的一个实例。

<img src="C:\Users\Yiming\Documents\课程相关\自学\assets\mvc-filesystem.png" alt="Model-View-Controller 模式，如文件系统浏览器中所示" style="zoom:50%;" />

下面是一个更大的示例，其中视图是文件系统浏览器（如 Mac Finder 或 Windows 资源管理器），模型是磁盘文件系统，控制器是输入处理程序，它将用户的击键和鼠标单击转换为对模型和视图的操作。

模型和视图的分离有几个好处。首先，它允许界面具有多个视图来显示相同的应用程序数据。例如，数据库字段可能同时显示在表格和可编辑表单中。其次，它允许在其他应用程序中重用视图和模型。MVC 模式支持创建用户界面工具包，这些工具包是可重用视图的库。Java Swing 就是这样一个工具包。您可以轻松地重用此库中的视图类（如`JButton`和`JTree`），同时将自己的模型插入其中。

## 图形用户界面中的后台处理

今天的最后一个主要主题回到并发性。

首先，一些动力。为什么我们需要在图形用户界面中进行后台处理？尽管计算机系统的速度正在稳步提高，但我们也要求他们做更多的事情。许多程序需要执行可能需要一些时间的操作：通过网络检索 URL、运行数据库查询、扫描文件系统、进行复杂的计算等。

但是图形用户界面是事件驱动的程序，这意味着（通常）一切都是由输入事件处理程序触发的。例如，在 Web 浏览器中，单击超链接将开始加载新网页。但是，如果编写点击处理程序以使其实际检索网页本身，那么 Web 浏览器使用起来将非常痛苦。为什么？因为它的界面看起来会冻结，直到点击处理程序完成检索网页并返回事件循环。原因如下。

发生这种情况是因为输入处理和屏幕重绘都是从单个线程处理的。该线程（称为事件调度线程）有一个循环，该循环从队列中读取输入事件并将其调度给视图树上的侦听器。当没有要处理的输入事件时，它会重新绘制屏幕。但是，如果您编写的输入处理程序延迟返回此循环 — 因为它在网络读取上阻塞，或者因为它正在搜索一个大型数独难题的解决方案 — 则输入事件将停止处理，并且屏幕将停止更新。这么长的任务需要在后台运行。

在 Java 中，事件调度线程（event-dispatch thread）与程序的主线程不同（见下文）。它在创建用户界面对象时自动启动。因此，每个 Java GUI 程序都自动进行多线程处理。许多程序员没有注意到，因为主线程在 GUI 程序中通常不会做太多事情 – 它开始创建视图，然后主线程只是退出，只留下事件调度线程来执行程序的主要工作。

默认情况下，Swing 程序是多线程的这一事实会产生风险。GUI 中通常有一个共享的可变数据类型：模型。如果使用后台线程修改模型而不阻止事件调度线程，则必须确保数据结构是线程安全的。

但是 GUI 中另一个重要的共享可变数据类型是视图树。Java Swing 的视图树不是线程安全的。通常，除了事件调度线程之外，您无法从任何位置安全地调用 Swing 对象上的方法。

视图树是一个共享状态的大肉球，Swing 规范不保证有任何锁保护它。相反，视图树被**规范限制在事件调度线程** 中。因此，从事件调度线程访问视图对象是可以的（即，响应 Importing 事件），但是 Swing 规范禁止从其他线程触摸（读取或写入）任何`JComponent`对象。请参阅 [Swing threading 和 event-dispatch thread ](https://www.javaworld.com/javaworld/jw-08-2007/jw-08-swingthreading.html)。

在实际的 Swing 实现中，有一个大锁（ [`Component.getTreeLock()`](https://docs.oracle.com/javase/8/docs/api/java/awt/Component.html#getTreeLock--)），但只有一些 Swing 方法使用它，因此它作为同步机制无效。

访问视图树的安全方法是从实践调度线程执行此操作。因此，Swing 采用了一种聪明的方法：它使用事件队列本身作为消息传递队列。换句话说，您可以将自己的自定义消息放在事件队列中，该队列用于鼠标单击、按键、按钮操作事件等。您的自定义消息实际上是一段可执行代码，一个实现` Runnable`的对象，您可以使用 [`SwingUtilities.invokeLater`](https://docs.oracle.com/javase/8/docs/api/javax/swing/SwingUtilities.html#invokeLater-java.lang.Runnable-)将其放在队列中。例如：

```java
SwingUtilities.invokeLater(new Runnable() { 
    public void run() { 
        content.add(thumbnail); 
        ...
    } 
});
```

`invokeLater()`会在队列末尾放置`Runnable`对象，当 Swing 的事件循环到达它时，它只需调用`run()`。因此，`run()`的主体最终由 event-dispatch 线程运行，在那里它可以安全地调用视图树上的 observer 和 mutator。

## 总结

- 视图树将屏幕组织成一个嵌套矩形树，用于调度输入事件以及显示输出。
- 侦听器模式将事件流（如鼠标或键盘事件或按钮操作事件）发送到已注册的侦听器。
- Model-View-Controller 模式将职责分开：model=data、view=output、controller=input。
- 长时间运行的处理应移至后台线程，但 Swing 视图树仅限于事件调度线程。因此，从另一个线程访问 Swing 对象需要将事件循环用作消息传递队列，以返回到事件调度线程。

# Reading 25: Map, Filter, Reduce（映射、过滤、精简）

## 简介：示例

假设我们面临以下问题：编写一个方法，在项目的 Java 文件中查找单词。

按照良好的实践，我们将其分解为几个更简单的步骤，并为每个步骤编写一个方法：

- 通过从项目的根文件夹递归扫描来查找项目中的所有文件
- 在这种情况下，将它们限制为具有特定后缀的文件` .java`
- 打开每个文件并逐行阅读
- 将每行分解为单词

为这些子步骤编写各个方法时，我们会发现自己编写了大量低级迭代代码。 例如，项目文件夹的递归遍历可能如下所示：

```java
/**
 * Find all the files in the filesystem subtree rooted at folder.
 * @param folder root of subtree, requires folder.isDirectory() == true
 * @return list of all ordinary files (not folders) that have folder as
 *         their ancestor
 */
public static List<File> allFilesIn(File folder) {
    List<File> files = new ArrayList<>();
    for (File f : folder.listFiles()) {
        if (f.isDirectory()) {
            files.addAll(allFilesIn(f));
        } else if (f.isFile()) {
            files.add(f);
        }
    }
    return files;
}
```

以下是过滤方法可能的样子，它将该文件列表限制为仅 Java 文件（想象一下这样称呼`onlyFilesWithSuffix(files, ".java")`）：

```java
/**
 * Filter a list of files to those that end with suffix.
 * @param files list of files (all non-null)
 * @param suffix string to test
 * @return a new list consisting of only those files whose names end with
 *         suffix
 */
public static List<File> onlyFilesWithSuffix(List<File> files, String suffix) {
    List<File> result = new ArrayList<>();
    for (File f : files) {
        if (f.getName().endsWith(suffix)) {
            result.add(f);
        }
    }
    return result;
}
```

[**→示例的完整 Java 代码**](https://github.com/mit6005/sp16-ex25-words/blob/master/src/words/Words1.java)

在本阅读中，我们讨论了 *map/filter/reduce* ，这是一种设计模式，它大大简化了对元素序列进行操作的函数的实现。 在这个例子中，我们将有很多序列 — 文件列表；作为行序列的输入流；作为单词序列的行；频率表是 （word， count） 对的序列。 Map/filter/reduce 将使我们能够在没有显式控制流的情况下对这些序列进行操作 — 而不是单个`for`循环或`if`语句。

在此过程中，我们还将看到一个重要的大概念：函数作为“一等”数据值，这意味着它们可以存储在变量中，作为参数传递给函数，并像其他值一样动态创建。

在 Java 中使用一等函数更冗长，使用一些不熟悉的语法，并且与静态类型的交互增加了一些复杂性。 因此，要开始使用 map/filter/reduce，我们将切换回 Python。

## 抽象出控制流

我们已经看到了一种从迭代数据结构的细节中抽象出来的设计模式：Iterator。

### 迭代器抽象

Iterator 为您提供数据结构中的元素序列，而无需担心数据结构是集合、标记流、列表还是数组——无论数据结构是什么，[`Iterator`](https://docs.oracle.com/javase/8/docs/api/?java/util/Iterator.html)看起来都是一样的。

例如，给定一个`List<File> files`，我们可以使用 indices 进行迭代：

```java
for (int ii = 0; ii < files.size(); ii++) {
    File f = files.get(ii);
    // ...
```

但是这段代码依赖于`List`的`size`和`get`方法，这在另一个数据结构中可能有所不同。 使用迭代器可以抽象出细节：

```java
Iterator<File> iter = files.iterator();
while (iter.hasNext()) {
    File f = iter.next();
    // ...
```

现在，对于提供`Iterator`。实际上，此类类型有一个接口： [`Iterable`](https://docs.oracle.com/javase/8/docs/api/?java/lang/Iterable.html)。 任何`Iterable`可以与 Java [的增强 for 语句](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html)一起使用 — `for (File f : files)` — 并且在后台，它使用了一个迭代器。

### Map/filter/reduce的抽象

此阅读中的 map/filter/reduce 模式与 Iterator 类似，但在更高的层次上：它们将整个元素序列视为一个单元，因此程序员不必单独命名和处理元素。 在这个范例中，控制语句消失了：具体来说，代码中我们介绍性示例中的`for`语句、`if`语句和`return`语句将消失。 我们还将能够删除大多数临时名称（即局部变量`files`、`f`和`result`）。

### 序列

让我们想象一个抽象数据类型`Seq<E>`，它表示**一个序列的**类型元素`E`。

例如，`[1, 2, 3, 4]` ∈ `Seq<Integer>`。

任何具有迭代器的数据类型都可以限定为序列：array、list、set 等。 字符串也是一个（字符）序列，尽管 Java 的字符串不提供迭代器。 Python 在这方面更加一致：不仅列表是可迭代的，而且字符串、元组（不可变列表）甚至输入流（产生一系列行）也是可迭代的。 我们将首先在 Python 中看到这些示例，因为语法非常可读且您熟悉，然后我们将了解它在 Java 中的工作原理。

我们将对序列进行三个操作：map、filter 和 reduce。 让我们依次看看每个选项，然后看看它们是如何协同工作的。

## Map

**Map** 将一元函数应用于序列中的每个元素，并按相同的顺序返回包含结果的新序列：

**map : (E → F) × Seq\<E\> → Seq\<F\>**

例如，在 Python 中：

```python
>>> from math import sqrt
>>> map(sqrt, [1, 4, 9, 16])
[1.0, 2.0, 3.0, 4.0]
>>> map(str.lower, ['A', 'b', 'C'])
['a', 'b', 'c']
```

`map`是内置的，但在 Python 中也很容易实现：

```python
def map(f, seq):
    result = []
    for elt in seq:
        result.append(f(elt))
    return result
```

此操作捕获了对 sequence 进行操作的常见模式：对 sequence 的每个元素执行相同的操作。

## 将函数作为值

让我们在这里暂停一下，因为我们正在对函数做一些不寻常的事情。该函数将对*函数*的引用作为其第一个参数，而不是该函数的结果。 当我们编写` map`

```python
map(sqrt, [1, 4, 9, 16])
```

我们没有调用sqrt（类似`sqrt(25)是一个调用`），而是只使用了它的名字。 在 Python 中，函数的名称是对表示该函数的对象的引用。 如果你愿意，你可以将该对象分配给另一个变量，它的行为仍然类似于：

```python
>>> mySquareRoot = sqrt
>>> mySquareRoot(25)
5.0
```

你也可以将对函数对象的引用作为参数传递给另一个函数，这就是我们在这里用`map`所做的。 您可以像在 Python 中使用任何其他数据值（如数字、字符串或对象）一样使用函数对象。

函数在 Python 中是**一流的**，这意味着它们可以分配给变量、作为参数传递、用作返回值并存储在数据结构中。 First-class functions 是一个非常强大的编程思想。 第一个使用它们的实用编程语言是 Lisp，它由 John McCarthy 在 MIT 发明。 但是，将函数作为一等值进行编程的想法实际上早于计算机，这可以追溯到 Alonzo Church 的 lambda 演算。 lambda 演算使用希腊字母 λ 来定义新函数;这个术语被卡住了，你不仅会在 Lisp 及其后代中看到它作为一个关键词，而且在 Python 中也会看到它。

我们已经了解了如何将内置库函数用作一等值;我们如何制作自己的产品？ 一种方法是使用熟悉的函数定义，它为函数命名：

```python
>>> def powerOfTwo(k):
...     return 2**k
... 
>>> powerOfTwo(5)                 
32
>>> map(powerOfTwo, [1, 2, 3, 4])
[2, 4, 8, 16]
```

但是，当您只需要在一个地方使用函数时（这通常出现在使用函数编程中），使用 **lambda 表达式** 会更方便：

```python
lambda k: 2**k
```

此表达式表示一个参数（称为`k`）的函数，该函数返回值 2^k^. 您可以在任何您想要使用的地方使用`powerOfTwo`：

```python
>>> (lambda k: 2**k)(5)
32
>>> map(lambda k: 2**k, [1, 2, 3, 4])
[2, 4, 8, 16]
```

遗憾的是，Python lambda 表达式在语法上受到限制，只能用一条`return`语句编写的函数（没有`if`语句、没有`for`循环、没有局部变量）。 但请记住，无论如何，这就是我们 map/filter/reduce 的目标，所以它不会是一个严重的障碍。

Python 的创建者 Guido Von Rossum 写了一篇关于设计原则的博客文章，该原则不仅导致了 Python 中的一流函数，还导致了一流的方法： [一流的 Everything ](https://python-history.blogspot.com/2009/02/first-class-everything.html)。

### map的更多使用方法

即使您不关心函数的返回值，Map 也很有用。 例如，当你有一个可变对象序列时，你可以在它们上面映射一个 mutator 操作：

```python
map(IOBase.close, streams) # closes each stream on the list
map(Thread.join, threads)  # waits for each thread to finish
```

某些版本的 map （包括Python的 built-in `map`）也支持具有多个参数的 map 函数。 例如，您可以按元素添加两个数字列表：

```python
>>> import operator
>>> map(operator.add, [1, 2, 3], [4, 5, 6])
[5, 7, 9]
```

## Filter

我们的下一个重要的序列操作是 **filter** ，它使用一元谓词测试每个元素。满足谓词的元素将被保留;那些没有的将被删除。将返回一个新列表；filter 不会修改其 Input 列表。

**filter : (E → boolean) × Seq<‍E> → Seq<‍E>**

Python 示例：

```python
>>> filter(str.isalpha, ['x', 'y', '2', '3', 'a']) 
['x', 'y', 'a']
```

```python
>>> def isOdd(x): return x % 2 == 1
... 
>>> filter(isOdd, [1, 2, 3, 4])
[1, 3]
```

```python
>>> filter(lambda s: len(s)>0, ['abc', '', 'd'])
['abc', 'd']
```

我们可以用一种简单的方式定义 filter：

```python
def filter(f, seq):
    result = []
    for elt in seq:
        if f(elt):
            result.append(elt)
    return result
```

## Reduce

我们的最后一个运算符 **reduce** 使用二元函数将序列的元素组合在一起。 除了函数和列表之外，它还需要一个*初始化 reduction 的初始值*，如果列表为空，则最终成为返回值。

**reduce : (F × E → F) × Seq<‍E> × F → F**

> result ~0~ = init
> result ~1~ = f(result ~0~ , list[0])
> result ~2~ = f(result ~1~ , list[1])
> ...
> result ~n~ = f(result ~n-1~ , list[n-1])

result~n~是 n 元素列表的最终结果。

数字相加可能是最直接的例子：

```java
>>> reduce(lambda x,y: x+y, [1, 2, 3], 0)
6
# --or--
>>> import operator
>>> reduce(operator.add, [1, 2, 3], 0)
6
```

reduce 操作中有两种设计选项。 首先是是否需要初始值。 在 Python 的 reduce 函数中，初始值是可选的，如果省略它，则 reduce 使用列表的第一个元素作为其初始值。 所以你得到的行为是这样的：

> result ~0~ = undefined (reduce throws an exception if the list is empty)
> result ~1~ = list[0]
> result ~2~ = f(result ~1~ , list[1])
> ...
> result ~n~ = f(result ~n-1~ , list[n-1])

这使得使用像`max`这样的 reducer 更容易，它们没有明确定义的初始值：

```python
>>> reduce(max, [5, 8, 3, 1])
8
```

第二个设计选择是元素的累积顺序。 对于像`add`和`max`这样的结合运算符，它没有区别，但对于其他运算符，它有区别。 Python 的 reduce 在其他编程语言中也称为 **fold-left**，因为它结合了从左侧（第一个元素）开始的序列。 **向右折叠**则相反：

**fold-right : (E × F → F) × Seq<‍E> × F → F**

其中`fold-right(f, list, init)` n 元素列表遵循以下模式：

> result ~0~ = init
> result ~1~ = f(list[n-1], result ~0~ )
> result ~2~ = f(list[n-2], result ~1~ )
> ...
> result ~n~ = f(list[0], result ~n-1~ )

产生 result~n~ 作为最终结果。

这是两种减少方法的图表：从左侧或从右侧：

![fold-left](C:\Users\Yiming\Documents\课程相关\自学\assets\fold-left.svg)

**fold-left( [1, 2, 3], 0, – )** = ((0 - 1) - 2) - 3 = -6

![fold-right](C:\Users\Yiming\Documents\课程相关\自学\assets\fold-right.svg)

**fold-right( [1, 2, 3], 0, – )** = 1 - (2 - (3 - 0)) = 2

reduce 操作的返回类型不必与 list 元素的类型匹配。 例如，我们可以使用 reduce 将序列粘合成一个字符串：

```python
>>> reduce(lambda s,x: s+str(x), [1, 2, 3, 4], '') 
'1234'
```

或者将嵌套的子列表展平为单个列表：

```python
>>> reduce(operator.concat, [[1, 2], [3, 4], [], [5]], [])
[1, 2, 3, 4, 5]
```

这是一个足够有用的序列操作，我们将它定义为 **flatten** ，尽管它只是一个 reduce 步骤：

```python
def flatten(list):
    return reduce(operator.concat, list, [])
```

### 更多示例

假设我们有一个多项式，表示为系数列表 a[0]， a[1]， ...， a[n-1]，其中 a[i] 是 x^i^ 的系数. 然后我们可以使用 map 和 reduce 来评估它：

```python
def evaluate(a, x):
    xi = map(lambda i: x**i, range(0, len(a))) # [x^0, x^1, x^2, ..., x^(n-1)]
    axi = map(operator.mul, a, xi)             # [a[0]*x^0, a[1]*x^1, ..., a[n-1]*x^(n-1)]
    return reduce(operator.add, axi, 0)        # sum of axi
```

此代码使用方便的 Python 方法生成器`range(a,b)` ，该方法生成从 a 到 b-1 的整数列表。 在 map/filter/reduce 编程中，这种方法取代了从 a 到 b 的索引`for`循环。

现在，让我们看一个典型的数据库查询示例。 假设我们有一个关于数码相机的数据库，其中每个对象都是`Camera`类型，其属性（`brand()`、`pixels()`、`cost()`等）具有观察者方法。 整个数据库位于名为`cameras`的列表中。 然后我们可以使用 map/filter/reduce 来描述这个数据库上的查询：

```python
# What's the highest resolution Nikon sells? 
reduce(max, map(Camera.pixels, filter(lambda c: c.brand() == "Nikon", cameras)))
```

关系数据库使用 map/filter/reduce 范例（称为 project/select/aggregate）。[SQL](https://en.wikipedia.org/wiki/SQL)（结构化查询语言）是查询关系数据库*的事实*标准语言。 典型的 SQL 查询如下所示：

```python
select max(pixels) from cameras where brand = "Nikon"
```

> `cameras`是一个**序列** （行列表，其中每行都包含一个摄像机的数据）
>
> `where brand = "Nikon"`是一个**过滤器**
>
> `pixels`是一个**映射** （仅从行中提取 pixels 字段）
>
> `max`是一个 **reduce**

## 回到开头的例子

回到我们开始的示例，我们想要在项目的 Java 文件中查找所有单词，让我们尝试创建一个有用的抽象来按后缀过滤文件：

```python
def fileEndsWith(suffix):
    return lambda file: file.getName().endsWith(suffix)
```

`fileEndsWith`返回可用作 filters 的*函数*：它接受类似`.java`的文件名称后缀，并动态生成一个函数，我们可以将其与 filter 一起使用来测试该后缀：

```python
filter(fileEndsWith(".java"), files)
```

`fileEndsWith`是一种与我们通常的功能不同的野兽。 它是一个**高阶函数** ，这意味着它是一个将另一个函数作为参数，或返回另一个函数作为其结果的函数。 高阶函数是对函数数据类型的操作;在本例中，`fileEndsWith`是函数的生产者。

现在让我们使用 map、filter 和 flatten（我们在上面使用 reduce 定义）递归遍历文件夹树：

```python
def allFilesIn(folder):
    children = folder.listFiles()
    subfolders = filter(File.isDirectory, children)
    descendants = flatten(map(allFilesIn, subfolders))
    return descendants + filter(File.isFile, children)
```

第一行获取文件夹的所有子项，可能如下所示：

```python
["src/client", "src/server", "src/Main.java", ...]
```

第二行是关键位：它只过滤子文件夹的子文件夹，然后递归地映射`allFilesIn`到这个子文件夹列表！ 结果可能如下所示：

```python
[["src/client/MyClient.java", ...], ["src/server/MyServer.java", ...], ...]
```

所以我们必须将其扁平化以删除嵌套结构。 然后我们添加直接的子级，它们是普通文件（不是文件夹），这就是我们的结果。

我们也可以使用 map/filter/reduce 来做其他部分的问题。 一旦我们有了要从中提取单词的文件列表，我们就可以加载它们的内容了。 我们可以使用 map 将它们的路径名作为字符串获取，打开它们，然后将每个文件作为文件列表读入：

```python
pathnames = map(File.getPath, files)
streams = map(open, pathnames)
lines = map(list, streams)
```

这实际上看起来像一个单独的 map 操作，我们想将三个函数应用于元素，所以让我们暂停一下创建另一个有用的高阶函数：将函数组合在一起。

```python
def compose(f, g):
    """Requires that f and g are functions, f:A->B and g:B->C.
    Returns a function A->C by composing f with g.""" 
    return lambda x: g(f(x))
```

现在我们可以使用单个 map：

```python
lines = map(compose(compose(File.getPath, open), list), files)
```

更好的是，既然我们已经有三个函数要应用，让我们设计一种方法来组合一个任意的函数链：

```python
def chain(funcs):
    """Requires funcs is a list of functions [A->B, B->C, ..., Y->Z]. 
    Returns a fn A->Z that is the left-to-right composition of funcs."""
    return reduce(compose, funcs)
```

因此，map 操作变为：

```python
lines = map(chain([File.getPath, open, list]), files)
```

现在，我们看到了 first-class 函数的更多功能。 我们可以将函数放入数据结构中，并在这些数据结构上使用操作，例如 map、reduce 和 filter，以及函数本身！

由于此 map 将生成一个行列表（每个文件一个行列表），让我们将其展平以获得单个行列表，忽略文件边界：

```python
allLines = flatten(map(chain([File.getPath, open, list]), files))
```

然后我们以类似的方式将每一行拆分为单词：

```python
words = flatten(map(str.split, lines))
```

大功告成，我们有了项目 Java 文件中的所有单词列表！ 正如承诺的那样，控制语句已经消失了。

## 抽象出控件的好处

Map/filter/reduce 通常可以使代码更短、更简单，并允许程序员专注于计算的核心，而不是循环、分支和控制流的细节。

通过根据 map、filter 和 reduce 来安排我们的程序，特别是尽可能多地使用不可变数据类型和纯函数（不改变数据的函数），我们为安全并发创造了更多机会。 在不可变数据类型上使用纯函数的映射和过滤器可以立即并行化 — 对序列的不同元素的函数调用可以在不同的线程、不同的处理器甚至不同的机器上运行，并且结果仍然是相同的。[MapReduce](https://en.wikipedia.org/wiki/MapReduce)是一种以这种方式并行化大型计算的模式。

## Java 中的一等函数

我们已经看到了 Python 中的一等函数是什么样子的;这一切在 Java 中是如何工作的？

在 Java 中，唯一的一等值是原始值（整数、布尔值、字符等）和对象引用。 但是对象可以以方法的形式携带函数。 因此，事实证明，在面向对象的编程语言（如 Java）中，不直接支持第一类函数，实现第一类函数的方法是使用具有表示该函数的方法的对象。

实际上，我们之前已经多次看到这种情况：

- 传递给`Thread`构造函数的`Runnable`对象是一等函数，`void run()`。
- 传递给排序集合（例如`SortedSet`）的对象`Comparator<T>`是一等函数，`int compare(T o1, T o2)`。
- 向图形用户界面工具包注册以获取键盘事件的`KeyListener`对象是多个函数`keyPressed(KeyEvent)`、`keyReleased`等的捆绑包。

这种设计模式称为 **functional object** 或 **functor** ，其目的是表示函数的对象。

### Java 中的 Lambda 表达式

Java 的 lambda 表达式语法提供了一种创建功能对象实例的简洁方法。 例如，相较于编写：

```java
new Thread(new Runnable() {
    public void run() {
        System.out.println("Hello!");
    }
}).start();
```

我们可以使用一个 lambda 表达式：

```java
new Thread(() -> {
    System.out.println("Hello");
}).start();
```

这里没有什么神奇之处：Java 仍然没有一流的函数。 因此，只有当 Java 编译器可以验证以下两件事时，您才能使用 lambda：

1. 它必须能够确定 lambda 将创建的功能对象的类型。 在此示例中，编译器看到`Thead`构造函数接受一个`Runnable`，因此它将推断类型必须是`Runnable`。
2. 这个推断的类型必须是函数型接口：只有一个（抽象）方法的接口。 在此示例中，`Runnable`确实只有一个方法 — `void run()` — 因此编译器知道 lambda 主体中的代码属于新`Runnable`对象的`run`方法主体。

Java 提供了一些[标准的功能接口](https://docs.oracle.com/javase/8/docs/api/?java/util/function/package-summary.html)，我们可以用来在 map/filter/reduce 模式中编写代码，例如：

- [`Function`](https://docs.oracle.com/javase/8/docs/api/?java/util/function/Function.html)表示从`T`到`R`的一元函数
- [`BiFunction`](https://docs.oracle.com/javase/8/docs/api/?java/util/function/BiFunction.html)表示从`T`×`U`到`R`
- [`Predicate`](https://docs.oracle.com/javase/8/docs/api/?java/util/function/Predicate.html)表示函数从`T`到布尔值

所以我们可以像这样在 Java 中实现 map：

```java
/**
 * Apply a function to every element of a list.
 * @param f function to apply
 * @param list list to iterate over
 * @return [f(list[0]), f(list[1]), ..., f(list[n-1])]
 */
public static <T,R> List<R> map(Function<T,R> f, List<T> list) {
    List<R> result = new ArrayList<>();
    for (T t : list) {
        result.add(f.apply(t));
    }
    return result;
}
```

下面是一个使用 map 的示例;首先，我们将使用熟悉的语法编写它：

```java
// anonymous classes like this one are effectively lambda expressions
Function<String,String> toLowerCase = new Function<>() {
    public String apply(String s) { return s.toLowerCase(); }
};
map(toLowerCase, Arrays.asList(new String[] {"A", "b", "C"}));
```

并使用 lambda 表达式：

```java
map(s -> s.toLowerCase(), Arrays.asList(new String[] {"A", "b", "C"}));
// --or--
map((s) -> s.toLowerCase(), Arrays.asList(new String[] {"A", "b", "C"}));
// --or--
map((s) -> { return s.toLowerCase(); }, Arrays.asList(new String[] {"A", "b", "C"}));
```

在此示例中，lambda 表达式只是包装对`String`的`toLowerCase`的调用。 我们可以使用*方法引用*来避免编写 lambda，语法为`::`。我们引用的方法的签名必须与满足静态类型的函数接口所需的签名匹配：

```java
map(String::toLowerCase, Arrays.asList(new String[] {"A", "b", "C"}));
```

在 Java 教程中，如果需要详细信息，可以阅读有关[**方法引用**](https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html)的更多信息。

在 Java 中使用方法引用（而不是调用它）与在 Python 中按名称引用函数（而不是调用它）具有相同的目的。

## Java 中的 map/filter/reduce

我们上面定义的[抽象序列类型](https://ocw.mit.edu/ans7870/6/6.005/s16/classes/25-map-filter-reduce/#sequences)在 Java 中作为[`Stream`](https://docs.oracle.com/javase/8/docs/api/?java/util/stream/Stream.html)存在，它定义了`map`、`filter`、`reduce`和许多其他操作。

集合类型（如`List`和`Set`）提供了一个为集合返回一个`Stream`的操作，并且有一个用于从数组创建一个`Stream`的`Arrays.stream`函数。

这是 Java 中一个使用 map 和 filter 的`allFilesIn`实现：

```java
public class Words {
    static Stream<File> allFilesIn(File folder) {
        File[] children = folder.listFiles();
        Stream<File> descendants = Arrays.stream(children)
                                         .filter(File::isDirectory)
                                         .flatMap(Words::allFilesIn);
        return Stream.concat(descendants,
                             Arrays.stream(children).filter(File::isFile));
    }
```

map-and-flatten 模式非常常见，以至于 Java 提供了一个`flatMap`操作来执行此操作，我们使用它来代替定义`flatten`。

这是`endsWith`：

```java
    static Predicate<File> endsWith(String suffix) {
        return f -> f.getPath().endsWith(suffix);
    }
```

给定一个`Stream<File> files`，我们现在可以写成例如`files.filter(endsWith(".java"))`以获取新的过滤流。

## Java 中的高阶函数

Map/filter/reduce 当然是高阶函数；上面的`endsWith`也是这样。 让我们看看我们之前看到的另外两个值：`compose`和`chain`。

该`Function`接口提供了`compose` — 但实现非常简单。 特别是，一旦你获得了正确的参数类型和返回值，Java 的静态类型几乎不可能弄错方法主体：

```java
/**
 * Compose two functions.
 * @param f function A->B
 * @param g function B->C
 * @return new function A->C formed by composing f with g
 */
public static <A,B,C> Function<A,C> compose(Function<A,B> f,
                                            Function<B,C> g) {
    return t -> g.apply(f.apply(t));
    // --or--
    // return new Function<A,C>() {
    //     public C apply(A t) { return g.apply(f.apply(t)); }
    // };
}
```

事实证明，我们不能用强类型的 Java 编写`chain`，因为`List`（和其他集合）必须是同构的——我们可以指定一个列表，其元素都是`Function<A,B>`类型 ，但不能指定第一个元素是一个`Function<A,B>`，第二个元素是一个`Function<B,c>`，依此类推。

但这是`chain`针对相同 input/output 类型的函数：

```java
/**
 * Compose a chain of functions.
 * @param funcs list of functions A->A to compose
 * @return function A->A made by composing list[0] ... list[n-1]
 */
public static <A> Function<A,A> chain(List<Function<A,A>> funcs) {
    return funcs.stream().reduce(Function.identity(), Function::compose);
}
```

我们的 Python 版本没有在`reduce`中使用初始值，它需要一个非空的函数列表。 在 Java 中，我们提供了标识函数（即 *f(t) = t* ）作为缩减的标识值。

## 总结

本阅读内容是关于对问题进行建模和实现具有*不可变数据和*操作的系统 实现 *纯函数* ，而不是具有*副作用* 的*可变数据和*操作 。 *函数式编程*是这种编程风格的名称。

当你的语言中有*一流的函数*时，函数式编程要容易得多，而且你可以构建*高阶函数*来抽象出控制流代码。

一些语言 — [Haskell ](https://www.haskell.org/)、 [Scala ](https://www.scala-lang.org/)、 [OCaml ](https://ocaml.org/)— 与函数式编程密切相关。 许多其他语言 — [JavaScript](https://developer.mozilla.org/en-US/docs/JavaScript)， [Swift](https://developer.apple.com/swift/)， [几种 ](https://msdn.microsoft.com/en-us/library/67ef8sbd.aspx)[.NET ](https://fsharp.org/)[languages](https://msdn.microsoft.com/en-us/vstudio/hh388573.aspx)， [Ruby ](https://www.ruby-lang.org/)等 — 或多或少地使用函数式编程。 借助 Java 最近添加的函数式语言功能，如果您继续使用 Java 编程，您也应该会看到更多的函数式编程。
