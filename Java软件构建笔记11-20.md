[TOC]

# Reading 11: Debugging（调试）

## Reproduce the Bug（重现错误）

首先找到一个产生故障的小型、可重复的测试用例。（二分查找是个好办法）

如果是通过回归测试发现的，则更是一件幸运的事。如果是用户报告的，则需要一些努力来复线错误。

将故障小型化，可重复之后，测试用例要加入到回归测试套件中。

## 了解错误的位置和原因

1. **研究数据。** 查看导致 bug 的测试输入，以及由此导致的错误结果、失败的断言和堆栈跟踪。
2. **假设。** 提出一个与所有数据一致的假设，说明错误可能在哪里，或者*不可能*在哪里。 首先使这个假设成为普遍性是件好事。
3. **实验。** 设计一个实验来检验你的假设。 一开始让实验成为*观察*是件好事——一个收集信息但尽可能少干扰系统的探测器。
4. **重复。** 将您从实验中收集的数据添加到您之前知道的数据中，并做出新的假设。 希望您已经排除了一些可能性，并缩小了错误可能的位置和原因的范围。

# 一些小提示

**通过二分搜索进行 bug 定位** 。

**优先考虑你的假设** 。充分测试的旧代码、Java库代码，比你的代码要可信。

**交换组件** 。 例如，如果您怀疑您的`binarySearch()`实现，请替换更简单的`linearSearch()`。 

**确保您的源代码和目标代码是最新的。**更新到最新版本，删除所有二进制文件并重新编译所有内容.

**获取帮助。** 向别人解释你的问题通常会有所帮助，即使你正在与之交谈的人不知道你在说什么。

**把问题留到第二天解决。**累了就歇歇。

## 修复 Bug

* 避免在上面直接打补丁。
* 找到错误原因：是编码错误、设计错误，还是什么其他问题。可能要重新设计。
* 考虑和失败接口关联的其他部分。如客户端、其他同样设计的代码。
* 将bug的测试用例加入回归测试套件中。

# Reading 12: Abstract Data Types（ADT）（抽象数据类型）

## 抽象（Abstract）意味着什么

抽象数据类型，是软件工程中一般原则的一个实例。

* 抽象化（Abstraction）。省略或隐藏低级细节，采用更简单、更高层次的想法。
* 模块化（Modularity）。将系统划分为多个组件或模块，每个组件或模块都可以独立于系统的其余部分进行设计、实现、测试、推理和重用。
* 封装（Encapsulation）。在模块（硬壳或胶囊）周围构建墙，以便模块对自己的内部行为负责，而系统其他部分的错误不会破坏其完整性。
* 信息隐藏（Information hiding）。从系统的其余部分隐藏模块实现的细节，以便以后可以在不更改系统其余部分的情况下更改这些细节。
* 关注点分离（Separation of concerns）。使特性（或“关注点”）成为单个模块的责任，而不是将其分散到多个模块中。

## 对类型和操作进行分类

类型，无论是内置的还是用户定义的，都可以分为可变或不可变的。

抽象类型的操作分类如下：

* **创建者**：创建该类型的新对象。 创建者可以将对象作为参数，但不能将正在构造的类型的对象作为参数。
* **生产者**：从该类型的旧对象创建新对象。 例如，`String`的方法`concat`是一个生产者：它接受两个字符串并产生一个新字符串来表示它们的连接。
* **观察者**：获取抽象类型的对象并返回不同类型的对象。 例如，`List`的方法`size()`返回一个 `int`。
* **赋值器**：更改对象。 例如，`List`的方法`add()`通过在末尾添加元素来改变列表。

可以示意性地表示为：

* creator : t* → T
* producer : T+, t* → T
* observer : T+, t* → t
* mutator : T+, t* → void | t | T

其中，T是抽象数据类型，t是其他数据类型。

### 一些示例

`List`是 Java 的列表类型，是可变的，也是一个接口。

- 创建者： [`Collections.singletonList`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#singletonList-T-)，`ArrayList`，`LinkedList`和构造函数，
- 生产者： [`Collections.unmodifiableList`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-T-)
- 观察员：` size`，`get`
- 赋值器：[`Collections.sort`](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#sort-java.util.List-)`，add`，`remove`和`addAll`

`String`是 Java 的字符串类型，是不可变的。

* 创作者：`String`构造函数
* 生产者：` concat`，`substring`，`toUpperCase`
* 观察员：` length`，`charAt`
* 赋值器：无（它是不可变的）

## 设计抽象类型

* **少量简单的操作**。可以组合在一起形成强大功能，而不是本身就是大量复杂操作。
* 有明确定义的目的和**连贯**的行为，而不是一阵套特殊情况。例如`List`的`sum`方法，只对数值类型使用就可以了，不用考虑字符等特殊类型，否则会变得难以理解和使用。
* 操作集应当是**足够**的。必须有足够的操作来执行客户端可能想执行的计算类型。一个很好的测试是该类型的每个属性都可以提取。
* 类型可以是泛型的，但**不应混合使用通用功能和特定于域的功能**。

## 表示独立性（Representation Independence）

一个好的抽象数据类型应该是**与表示无关**的。这意味着抽象类型的使用与其表示形式（用于实现它的实际数据结构或数据字段）无关，因此表示形式的更改对抽象类型本身之外的代码没有影响。 例如，`List`提供的操作与列表是表示为链表还是数组无关。

一个关于自己构建`String`的例子。

ADT如下：

```java
/** MyString represents an immutable sequence of characters. */
public class MyString { 

    //////////////////// Example of a creator operation ///////////////
    /** @param b a boolean value
     *  @return string representation of b, either "true" or "false" */
    public static MyString valueOf(boolean b) { ... }

    //////////////////// Examples of observer operations ///////////////
    /** @return number of characters in this string */
    public int length() { ... }

    /** @param i character position (requires 0 <= i < string length)
     *  @return character at position i */
    public char charAt(int i) { ... }

    //////////////////// Example of a producer operation ///////////////    
    /** Get the substring between start (inclusive) and end (exclusive).
     *  @param start starting index
     *  @param end ending index.  Requires 0 <= start <= end <= string length.
     *  @return string consisting of charAt(start)...charAt(end-1) */
    public MyString substring(int start, int end) { ... }
}
```

测试优先原则：

```java
MyString s = MyString.valueOf(true);
assertEquals(4, s.length());
assertEquals('t', s.charAt(0));
assertEquals('r', s.charAt(1));
assertEquals('u', s.charAt(2));
assertEquals('e', s.charAt(3));
```

我们选择使用一个简单的表示形式：字符数组。

```java
private char[] a;
```

于是，实现操作代码如下：

```java
public static MyString valueOf(boolean b) {
    MyString s = new MyString();
    s.a = b ? new char[] { 't', 'r', 'u', 'e' } 
            : new char[] { 'f', 'a', 'l', 's', 'e' };
    return s;
}

public int length() {
    return a.length;
}

public char charAt(int i) {
    return a[i];
}

public MyString substring(int start, int end) {
    MyString that = new MyString();
    that.a = new char[end - start];
    System.arraycopy(this.a, start, that.a, 0, end - start);
    return that;
}
```

这时，我们想要检查参数是否在有效范围。这样有利于操作的性能改进。

于是我们将类的内部表示形式更改为：

```java
private char[] a;
private int start;
private int end;
```

完整的操作实现如下：

```java
public static MyString valueOf(boolean b) {
    MyString s = new MyString();
    s.a = b ? new char[] { 't', 'r', 'u', 'e' } 
            : new char[] { 'f', 'a', 'l', 's', 'e' };
    s.start = 0;
    s.end = s.a.length;
    return s;
}

public int length() {
    return end - start;
}

public char charAt(int i) {
  return a[start + i];
}

public MyString substring(int start, int end) {
    MyString that = new MyString();
    that.a = this.a;
    that.start = this.start + start;
    that.end = this.start + end;
    return that;
}
```

这就是**表示独立性**的用处。客户端只依赖于公共方法，而不依赖于私有字段，所以可以进行更改，而不用修改客户端代码。

## 在 Java 中实现 ADT 概念

| ADT概念            | 在 Java 中执行此操作的方法                                   | 例子                                                         |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Creator operation  | 构造函数（Constructor）, 静态（工厂）方法（Static (factory) method）, 常量（Constant） | `ArrayList()` `Collections.singletonList()` `Arrays.asList()` `BigInteger.ZERO` |
| Observer operation | 实例方法（Instance method）, 静态方法（Static method）       | `List.get()` `Collections.max()`                             |
| Producer operation | 实例方法（Instance method）, 静态方法（Static method）       | `String.trim()` `Collections.unmodifiableList()`             |
| Mutator operation  | 实例方法（Instance method）, 静态方法（Static method）       | `List.add()` `Collections.copy()`                            |
| Representation     | `private`字段                                                |                                                              |

## 测试ADT

ADT的几个概念相互影响，所以测试需要按流程一系列操作。

在`MyString`上进行测试：

```java
// testing strategy for each operation of MyString:
//
// valueOf():
//    true, false
// length(): 
//    string len = 0, 1, n
//    string = produced by valueOf(), produced by substring()
// charAt(): 
//    string len = 1, n
//    i = 0, middle, len-1
//    string = produced by valueOf(), produced by substring()
// substring():
//    string len = 0, 1, n
//    start = 0, middle, len
//    end = 0, middle, len
//    end-start = 0, n
//    string = produced by valueOf(), produced by substring()
```

然后，涵盖所有这些分区的紧凑测试套件可能如下所示：

```java
@Test public void testValueOfTrue() {
    MyString s = MyString.valueOf(true);
    assertEquals(4, s.length());
    assertEquals('t', s.charAt(0));
    assertEquals('r', s.charAt(1));
    assertEquals('u', s.charAt(2));
    assertEquals('e', s.charAt(3));
}

@Test public void testValueOfFalse() {
    MyString s = MyString.valueOf(false);
    assertEquals(5, s.length());
    assertEquals('f', s.charAt(0));
    assertEquals('a', s.charAt(1));
    assertEquals('l', s.charAt(2));
    assertEquals('s', s.charAt(3));
    assertEquals('e', s.charAt(4));
}

@Test public void testEndSubstring() {
    MyString s = MyString.valueOf(true).substring(2, 4);
    assertEquals(2, s.length());
    assertEquals('u', s.charAt(0));
    assertEquals('e', s.charAt(1));
}

@Test public void testMiddleSubstring() {
    MyString s = MyString.valueOf(false).substring(1, 2);
    assertEquals(1, s.length());
    assertEquals('a', s.charAt(0));
}

@Test public void testSubstringIsWholeString() {
    MyString s = MyString.valueOf(false).substring(0, 5);
    assertEquals(5, s.length());
    assertEquals('f', s.charAt(0));
    assertEquals('a', s.charAt(1));
    assertEquals('l', s.charAt(2));
    assertEquals('s', s.charAt(3));
    assertEquals('e', s.charAt(4));
}

@Test public void testSubstringOfEmptySubstring() {
    MyString s = MyString.valueOf(false).substring(1, 1).substring(0, 0);
    assertEquals(0, s.length());
}
```

# Reading 13: Abstraction Functions & Rep Invariants（抽象方法和表示不变量）

## Invariants（不变量）

一个好的 ADT ，其重要属性之一为：**保留了自己的不变量**

当 ADT 保留自己的不变量时，对代码的推理就变得容易得多。

### Immutability（不变性）

普通的 ADT 在 Java 中的实现：

```java
/**
 * This immutable data type represents a tweet from Twitter.
 */
public class Tweet {

    public String author;
    public String text;
    public Date timestamp;

    /**
     * Make a Tweet.
     * @param author    Twitter user who wrote the tweet
     * @param text      text of the tweet
     * @param timestamp date/time when the tweet was sent
     */
    public Tweet(String author, String text, Date timestamp) {
        this.author = author;
        this.text = text;
        this.timestamp = timestamp;
    }
}
```

从客户端很容易进行修改：（同时影响了不变性和表示的独立性）

```java
Tweet t = new Tweet("justinbieber", 
                    "Thanks to all those beliebers out there inspiring me every day", 
                    new Date());
t.author = "rbmllr";
```

Java 提供的语言机制来处理这种表示暴漏：

```java
public class Tweet {

    private final String author;
    private final String text;
    private final Date timestamp;

    public Tweet(String author, String text, Date timestamp) {
        this.author = author;
        this.text = text;
        this.timestamp = timestamp;
    }

    /** @return Twitter user who wrote the tweet */
    public String getAuthor() {
        return author;
    }

    /** @return text of the tweet */
    public String getText() {
        return text;
    }

    /** @return date/time when the tweet was sent */
    public Date getTimestamp() {
        return timestamp;
    }

}
```

但是，表示仍然暴漏在外，考虑如下客户端代码：

```java
/** @return a tweet that retweets t, one hour later*/
public static Tweet retweetLater(Tweet t) {
    Date d = t.getTimestamp();
    d.setHours(d.getHours()+1);
    return new Tweet("rbmllr", t.getText(), d);
}
```

该调用返回对 tweet `t`引用的同一对象`Date`的引用。`t.timestamp`和`d`是同一可变对象的别名。因此，当该日期对象被`d.setHours()`更改时，这也会影响`t`中的日期。

`Tweet`的不变性被打破了。问题在于泄露了对可变对象的引用，而该对象的不可变性依赖于该对象。我们以一种无法再保证其对象不可变的方式暴露了表示。

我们可以通过使用**防御性复制**来修补这种表示暴露：复制可变对象以避免泄露对表示的引用。代码如下：

```java
public Date getTimestamp() {
    return new Date(timestamp.getTime());
}
```

可变类型通常有一个复制构造函数，允许您创建复制现有实例值的新实例。但并非所有类型都支持。

`getTimestamp`依然有表示曝光风险，考虑如下客户端代码：

```java
/** @return a list of 24 inspiring tweets, one per hour today */
public static List<Tweet> tweetEveryHourToday () {
    List<Tweet> list = new ArrayList<Tweet>(); 
    Date date = new Date();
    for (int i = 0; i < 24; i++) {
        date.setHours(i);
        list.add(new Tweet("rbmllr", "keep it up! you can do it", date));
    } 
    return list;
}
```

请注意，Tweet 的构造函数保存了传入的引用，因此所有 24 个 Tweet 对象最终都使用相同的时间。

同样，我们可以使用**防御性复制**来解决问题，这次是在构造函数中：

```java
public Tweet(String author, String text, Date timestamp) {
    this.author = author;
    this.text = text;
    this.timestamp = new Date(timestamp.getTime());
}
```

通常，应仔细检查所有 ADT 操作的参数类型和返回类型。如果任何类型是可变的，请确保您的实现不会返回对其表示形式的直接引用。

无疑，这对性能也许有浪费。为什么不能通过仔细编写的规范来解决这个问题？

```java
/**
 * Make a Tweet.
 * @param author    Twitter user who wrote the tweet
 * @param text      text of the tweet
 * @param timestamp date/time when the tweet was sent. Caller must never 
 *                   mutate this Date object again!
 */
public Tweet(String author, String text, Date timestamp) {
```

当没有任何其他合理的替代方案时，有时会采用这种方法 - 例如，当可变对象太大而无法有效复制时。

但一旦出错，代价是巨大的。尽可能要保证抽象数据类型的不变性，防止表示暴漏至关重要。

更好的解决方案是首选**不可变类型**。

### 围绕可变数据类型的不可变包装器

Java 集合类提供了一个有趣的折衷方案：immutable wrappers（不可变的包装器）。

`Collections.unmodifiableList()`使用一个可变的`List`，然后包装起来，看起来像是`List`，但赋值器（`set()` `add()` `remove()`）被禁用。

缺点是运行时获得不可变性，但在编译时则不然。

## Rep Invariant and Abstraction Function（表示不变值和抽象函数）

现在，我们更深入地研究了抽象数据类型背后的理论。

在考虑抽象类型时，考虑两个值空间之间的关系会有所帮助。

表示值（或简称 rep 值）的空间由实际实现实体的值组成。在简单的情况下，抽象类型将作为单个对象实现，但更常见的是需要一个小型对象网络，因此这个值实际上通常是相当复杂的东西。不过，就目前而言，只需将其视为一个数学值就足够了。

抽象值的空间由类型设计为支持的值组成。这些都是我们想象的虚构。它们是柏拉图式的实体，如所描述的那样不存在，但它们是我们想要查看抽象类型元素的方式，作为该类型的客户。例如，无界整数的抽象类型可能将数学整数作为其抽象值空间;例如，它可能被实现为原始（有界）整数数组，这一事实与该类型的用户无关。

现在，当然，抽象类型的实现者必须对表示值感兴趣，因为实现者的工作是使用表示值空间实现抽象值空间的错觉。

例如，假设我们选择使用字符串来表示一组字符：

```java
public class CharSet {
    private String s;
    ...
}
```

然后表示空间 R 包含字符串，抽象空间 A 是数学字符集。我们可以以图形方式显示两个值空间，从表示值到它所表示的抽象值的弧线。关于这张图片，有几点需要注意：

<img src="C:\Users\Yiming\Documents\课程相关\自学\assets\charset-af-ri-1723054658037-7.svg" alt="charset-af-ri" style="zoom: 33%;" />

- **每个抽象值都由某个 rep 值映射到** 。实现抽象类型的目的是支持对抽象值的操作。因此，据推测，我们需要能够创建和操作所有可能的抽象值，因此它们必须是可表示的。（类似数学中**满射**的概念）
- **一些抽象值由多个 rep 值映射到** 。发生这种情况是因为表示形式不是紧密编码。有多种方法可以将一组无序字符表示为字符串。（类似数学中**非单射**的概念）
- **并非所有 rep 值都已映射。** 在这种情况下，不会映射字符串“abbc”。在本例中，我们决定字符串不应包含重复项。这将使我们能够在命中特定字符的第一个实例时终止 remove 方法，因为我们知道最多可以有一个。（这点和数学中**映射**的概念相冲突）

在实践中，我们只能说明两个空间的几个元素及其关系;整个图形是无限的。因此，我们通过给出两件事来描述它：

1. 一个**抽象函数**（abstraction function），将表示值映射到它们所表示的抽象值：

> AF : R → A

2. 一个**表示不变量**（rep invariant），将表示值映射到布尔变量：

> RI : R → boolean

对于表示值 *r* ，当且仅当 *r* 由 *AF* 映射时， *RI（r）* 为真。换句话说， *RI* 告诉我们给定的 rep 值是否格式正确。或者，您可以将 *RI* 视为一个集合：它是定义 *AF* 的 rep 值的子集。

有了*RI*之后，经过*RI*筛选的表示值集合到抽象值集合，就满足了数学中的映射关系。严格满足满射且非单射。

rep 不变性和抽象函数都应该记录在代码中，紧挨着 rep 本身的声明：

<img src="C:\Users\Yiming\Documents\课程相关\自学\assets\charset-norepeats.svg" alt="charset-norepeats" style="zoom:33%;" />

```java
public class CharSet {
    private String s;
    // Rep invariant:
    //   s contains no repeated characters
    // Abstraction function:
    //   AF(s) = {s[i] | 0 <= i < s.length()}
    ...
}
```

关于抽象函数和 rep 不变量的一个常见混淆是，它们是由 rep 和抽象值空间的选择决定的，甚至是由抽象值空间单独决定的。如果是这样的话，它们就没什么用了，因为他们会说一些在其他地方已经可用的东西。

抽象值空间本身并不能确定 AF 或 RI：同一抽象类型可以有多种表示形式。一组字符同样可以表示为字符串（如上所述）或位向量，每个可能的字符对应一位。显然，我们需要两个不同的抽象函数来映射这两个不同的表示值空间。

不太明显的是，为什么两个空间的选择并不能决定 AF 和 RI。关键是，为 rep 定义类型，从而为 rep 值的空间选择值，并不能确定哪些 rep 值将被视为合法，而在那些合法的 rep 值中，它们将如何被解释。正如我们上面所做的那样，我们不是决定字符串没有重复项，而是允许重复项，但同时要求对字符进行排序，以不递减的顺序出现。这将允许我们对字符串执行二进制搜索，从而检查对数时间而不是线性时间的成员资格。相同的表示值空间 – 不同的表示不变性：

<img src="C:\Users\Yiming\Documents\课程相关\自学\assets\charset-sorted.svg" alt="charset-sorted" style="zoom:33%;" />

```java
public class CharSet {
    private String s;
    // Rep invariant:
    //   s[0] <= s[1] <= ... <= s[s.length()-1]
    // Abstraction function:
    //   AF(s) = {s[i] | 0 <= i < s.length()}
    ...
}
```

即使 rep 值空间使用相同的类型和相同的 rep 不变 RI，我们仍然可能以不同的方式解释 rep，使用不同的抽象函数 AF。假设 RI 允许任何字符串。然后，我们可以定义 AF，如上所述，将数组的元素解释为集合的元素。但是，没有*先验*的理由让表示来决定解释。也许我们会将连续的字符对解释为子范围，以便字符串 rep `"acgg"`被解释为两个范围对，[a-c] 和 [g-g]，因此表示集合 {a，b，c，g}。以下是该表示形式的 AF 和 RI 的外观：

<img src="C:\Users\Yiming\Documents\课程相关\自学\assets\charset-sortedrange.svg" alt="charset-sortedrange" style="zoom:33%;" />

```java
public class CharSet {
    private String s;
    // Rep invariant:
    //   s.length() is even
    //   s[0] <= s[1] <= ... <= s[s.length()-1]
    // Abstraction function:
    //   AF(s) = union of { c | s[2i] <= c <= s[2i+1] } 
    //           for all 0 <= i < s.length()/2
    ...
}
```

关键的一点是，设计抽象类型**不仅意味着选择两个空间——** 规范的抽象值空间和实现的 rep 值空间—— **而且还要决定使用什么 rep 值以及如何解释它们** 。

正如我们上面所做的那样，在你的代码中写下这些假设是至关重要的，这样未来的程序员（以及你未来的自己）才能知道这种表示的实际含义。为什么？如果不同的实现者对表示的含义存在分歧，会发生什么情况？

### 示例：Rational Numbers（有理数）

```java
public class RatNum {

    private final int numer; // 英文中的“分子（numerator）”
    private final int denom; // 英文中的“分母（denominator）”

    // Rep invariant:
    //   denom > 0
    //   numer/denom is in reduced form

    // Abstraction Function:
    //   represents the rational number numer / denom

    /** Make a new Ratnum == n.
     *  @param n value */
    public RatNum(int n) {
        numer = n;
        denom = 1;
        checkRep();
    }

    /** Make a new RatNum == (n / d).
     *  @param n numerator
     *  @param d denominator
     *  @throws ArithmeticException if d == 0 */
    public RatNum(int n, int d) throws ArithmeticException {
        // reduce ratio to lowest terms
        int g = gcd(n, d);
        n = n / g;
        d = d / g;

        // make denominator positive
        if (d < 0) {
            numer = -n;
            denom = -d;
        } else {
            numer = n;
            denom = d;
        }
        checkRep();
    }
}
```

下面是此代码的抽象函数和 rep 不变量的图片。RI 要求分子/分母对采用简化形式（即最低项），因此上述 （2,4） 和 （18,12） 等对应作为 RI 之外绘制。

<img src="C:\Users\Yiming\Documents\课程相关\自学\assets\ratnum-af-ri.png" alt="RatNum 的抽象函数和 rep 不变量" style="zoom: 67%;" />

使用更宽松的 RI 设计同一 ADT 的另一个实现是完全合理的。通过这样的更改，某些操作的执行成本可能会更高，而其他操作则更便宜。

### 检查 rep 不变量

rep 不变量不仅仅是一个简洁的数学思想。如果您的实现在运行时断言 rep 不变性，那么您可以及早捕获 bug。下面是一个测试其 rep 不变性的方法：

```java
// Check that the rep invariant is true
// *** Warning: this does nothing unless you turn on assertion checking
// by passing -enableassertions to Java
private void checkRep() {
    assert denom > 0;
    assert gcd(numer, denom) == 1;
}
```

当然，我们应该在创建或修改 rep 的每个操作结束时调用`checkRep()`以断言 rep 不变性——也就是创建者、生产者和赋值器操作。我们可以看到在两个构造函数的结尾，都调用了`checkRep()`。

观察者通常不需要调用`checkRep()`，但这仍然不失为一种很好的防御性做法。因为每一种方法（包括观察者）都意味着可能发生由表示值暴漏引发的表示不变性违规。

为什么`checkRep()`是私有的？谁应该负责检查和执行表示不变性——是客户端，还是实现者本身？

### 表示中没有 null 值

空值是麻烦和不安全的，我们试图将其从编程中删除。因此，我们在前置条件和后置条件中隐含地要求对象和数组为非空，表示不变量默认满足`x != null`。

我们将这个禁令扩展到 ADT 的表示中。但是，在实现表示不变量时，仍然必须实现空值检查，例如`s != null`检查，并确保当`s`为`null`时，`checkRep()`必须正确的失败。通常，这个检查在其他部分的 Java 代码中就完成了，你只需要报合适的异常就可以了，例如下面：

```java
private void checkRep() {
    assert s.length() % 2 == 0;
    ...
}
```

这样你就不需要`assert s != null`，因为调用`s.length()`时，会对空值做检查。但其他情况，需要你显式的完成断言`s != null`。

## 记录 AF、RI 和表示暴漏的安全性

在类中记录抽象函数和 rep 不变性是一种很好的做法，在声明 rep 的私有字段的地方使用注释。我们在上面一直在这样做。

6.005 要求您编写的另一份文档是 **表示暴露安全参数** 。这是一个注释，它检查了 rep 的每个部分，查看处理该 rep 部分的代码（特别是关于参数和来自客户端的返回值，因为这是 rep 暴露发生的地方），并提供了代码不暴露 rep 的原因。

下面是一个关于`Tweet`类和它的表示不变量的例子，抽象函数，以及完整记录的表示暴漏的安全性说明。

```java
// Immutable type representing a tweet.
public class Tweet {

    private final String author;
    private final String text;
    private final Date timestamp;

    // Rep invariant:
    //   author is a Twitter username (a nonempty string of letters, digits, underscores)
    //   text.length <= 140
    // Abstraction Function:
    //   represents a tweet posted by author, with content text, at time timestamp 
    // Safety from rep exposure:
    //   All fields are private;
    //   author and text are Strings, so are guaranteed immutable;
    //   timestamp is a mutable Date, so Tweet() constructor and getTimestamp() 
    //        make defensive copies to avoid sharing the rep's Date object with clients.

    // Operations (specs and method bodies omitted to save space)
    public Tweet(String author, String text, Date timestamp) { ... }
    public String getAuthor() { ... }
    public String getText() { ... }
    public Date getTimestamp() { ... }
}
```

请注意，我们在`timestamp`上没有任何明确的 rep 不变条件（除了我们对所有对象引用都有的传统假设`timestamp != null` ）。但是我们仍然需要在表示参数暴漏安全说明中包含`timestamp`，因为整个类型的不变性属性取决于所有字段保持不变。

以下是`RatNum`的参数暴漏安全说明。

```java
// Immutable type representing a rational number.
public class RatNum {
    private final int numer;
    private final int denom;

    // Rep invariant:
    //   denom > 0
    //   numer/denom is in reduced form, i.e. gcd(|numer|,denom) = 1
    // Abstraction Function:
    //   represents the rational number numer / denom
    // Safety from rep exposure:
    //   All fields are private, and all types in the rep are immutable.

    // Operations (specs and method bodies omitted to save space)
    public RatNum(int n) { ... }
    public RatNum(int n, int d) throws ArithmeticException { ... }
    ...
}
```

### 如何建立不变量

不变量是整个程序都为真的属性——在对象不变的情况下，它会减少到对象的整个生命周期。

要保持不变量，我们需要：

- 在对象的初始状态中使不变性为真；
- 确保对对象的所有更改都保持不变性为真。

根据 ADT 操作的类型来翻译这一点，这意味着：

- 创建者和生产者必须为新的对象实例建立不变性；
- 赋值器和观察者必须保持不变性。

表示暴露的风险使情况更加复杂。如果 rep 是公开的，那么对象可能会在程序中的任何位置发生更改，而不仅仅是在 ADT 的操作中，我们不能保证在这些任意更改之后不变量仍然成立。因此，证明不变量的完整规则是：

**结构性诱导** .如果抽象数据类型的不变量为

1. 由创建者和生产者建立；
2. 由赋值器和观察者保存；
3. 不会发生表示暴露。

则，对于抽象数据类型的所有实例，不变性都为真。

## ADT 不变量替换前提条件

现在让我们把很多东西放在一起。精心设计的抽象数据类型的一个巨大优点是，它封装并强制执行了我们原本必须在前提条件中规定的属性。例如，而不是像这样的规范，有一个详细的先决条件：

```java
/** 
 * @param set1 is a sorted set of characters with no repeats
 * @param set2 is likewise
 * @return characters that appear in one set but not the other,
 *  in sorted order with no repeats 
 */
static String exclusiveOr(String set1, String set2);
```

我们可以改用一个 ADT 来捕获所需的属性：

```java
/** @return characters that appear in one set but not the other */
static SortedSet<Character> exclusiveOr(SortedSet<Character>  set1, SortedSet<Character> set2);
```

这更容易理解，因为 ADT 的名称传达了程序员需要知道的所有信息。它也更安全，因为 Java 静态检查开始发挥作用，并且所需的条件（排序，没有重复）可以在一个地方强制执行，即 [`SortedSet`](https://docs.oracle.com/javase/8/docs/api/?java/util/SortedSet.html)类型。

我们在问题集上使用前提条件的许多地方都会从自定义 ADT 中受益。

## 总结

- 不变性是 ADT 对象实例在对象的生存期内始终为 true 的属性。
- 一个好的 ADT 会保留其自身的不变量。不变量必须由创建者和生产者建立，并由观察者和赋值器保留。
- rep 不变性指定了表示的合法值，应在运行时使用`checkRep()`
- 抽象函数将具体表示映射到它所表示的抽象值。
- 表示暴露既威胁到表示独立性，也威胁到不变性。

# Reading 14: Interfaces（接口）

## 接口

Java 是一种用于表达抽象数据类型的有用语言机制。 Java 中的接口是方法签名的列表，但没有方法主体。

如果类在其子句中声明了接口，则该类需要**实现（implement）**接口，并为接口的所有方法提供方法主体。 因此，在 Java 中定义抽象数据类型的一种方法是作为接口，其实现作为实现该接口的类。

优点：

* 接口为客户端指定了合同，而没有更多内容。 客户端程序员只需阅读该接口即可理解 ADT。 客户端不能无意中对 ADT 的表示创建依赖项，因为实例变量根本不能放在接口中。
* 抽象数据类型的多种不同表示形式可以作为实现接口的不同类在同一程序中共存。当抽象数据类型仅表示为单个类时，如果没有接口，则更难有多个表示形式。

## 子类型（Subtypes）

类型是一组值。比如，Java 的`List`类型是由它的接口定义的，但`List`的值中，却都不是`List`的对象，而是`ArrayList`和`LinkedList`。我们无法创建接口的实例，我们创建的，是实现了接口的对象。子类型（Subtype），是父类型（Supertype）的子集。`ArrayList`和`LinkedList`就是`List`的子类型。

“B 是 A 的子类型”意味着“每个 B 都是 A”。 在规格方面：“每个B都满足A的规格”。这意味着，如果 B 的规格至少与 A 的规格一样强，则 B 只是 A 的子类型。

## 例子：`MyString`

让我们重新审视一下`MyString`。 使用 ADT 的接口而不是类，我们可以支持多种实现：

```java
/** MyString represents an immutable sequence of characters. */
public interface MyString { 

    // We'll skip this creator operation for now
    // /** @param b a boolean value
    //  *  @return string representation of b, either "true" or "false" */
    // public static MyString valueOf(boolean b) { ... }

    /** @return number of characters in this string */
    public int length();

    /** @param i character position (requires 0 <= i < string length)
     *  @return character at position i */
    public char charAt(int i);

    /** Get the substring between start (inclusive) and end (exclusive).
     *  @param start starting index
     *  @param end ending index.  Requires 0 <= start <= end <= string length.
     *  @return string consisting of charAt(start)...charAt(end-1) */
    public MyString substring(int start, int end);
}
```

我们使用构造函数来完成第一个实现：

```java
public class SimpleMyString implements MyString {

    private char[] a;

    /* Create an uninitialized SimpleMyString. */
    private SimpleMyString() {}

    /** Create a string representation of b, either "true" or "false".
     *  @param b a boolean value */
    public SimpleMyString(boolean b) {
        a = b ? new char[] { 't', 'r', 'u', 'e' } 
              : new char[] { 'f', 'a', 'l', 's', 'e' };
    }

    @Override public int length() { return a.length; }

    @Override public char charAt(int i) { return a[i]; }

    @Override public MyString substring(int start, int end) {
        SimpleMyString that = new SimpleMyString();
        that.a = new char[end - start];
        System.arraycopy(this.a, start, that.a, 0, end - start);
        return that;
    }
}
```

下面是优化的实现：

```java
public class FastMyString implements MyString {

    private char[] a;
    private int start;
    private int end;

    /* Create an uninitialized FastMyString. */
    private FastMyString() {}

    /** Create a string representation of b, either "true" or "false".
     *  @param b a boolean value */
    public FastMyString(boolean b) {
        a = b ? new char[] { 't', 'r', 'u', 'e' } 
              : new char[] { 'f', 'a', 'l', 's', 'e' };
        start = 0;
        end = a.length;
    }

    @Override public int length() { return end - start; }

    @Override public char charAt(int i) { return a[start + i]; }

    @Override public MyString substring(int start, int end) {
        FastMyString that = new FastMyString();
        that.a = this.a;
        that.start = this.start + start;
        that.end = this.start + end;
        return that;
    }
}
```

* 我们使用构造函数替换了静态方法中的`valueOf`方法。
* 注意`@override`的使用。此注释通知编译器，该方法必须与我们正在实现的接口中的某个方法具有相同的签名。 但是，由于编译器已经检查了我们已经实现了所有接口方法，因此这里的主要价值是针对代码的读者。
* 当我们不声明任何其他构造函数时，Java 默认提供创建新实例的私有空构造函数。 添加接受的构造函数意味着我们必须显式声明空构造函数。

好的 ADT 会一丝不苟地保留自己的不变量，这些无所事事的构造函数是一个**糟糕**的模式：它们不会给 rep 分配任何值，当然也不会建立任何不变量。

客户使用此 ADT 的方法如下：

```java
MyString s = new FastMyString(true);
System.out.println("The first character is: " + s.charAt(0));
```

不幸的是，这种模式打破了我们一直在努力在抽象类型及其具体表示之间建立的**抽象障碍**。 客户端必须知道具体表示类的名称。 由于 Java 中的接口不能包含构造函数，因此它们必须直接调用具体类的构造函数之一。（就是那个实现`FastMyString`，用户不应该知道的）

幸运的是，（从 Java 8 开始）接口被允许包含静态方法，因此我们可以在接口`MyString`中将创建者操作`valueOf`实现为静态工厂方法：

```java
public interface MyString { 

    /** @param b a boolean value
     *  @return string representation of b, either "true" or "false" */
    public static MyString valueOf(boolean b) {
        return new FastMyString(true);
    }

    // ...
```

现在，客户端可以在不突破抽象障碍的情况下使用 ADT：

```java
MyString s = MyString.valueOf(true);
System.out.println("The first character is: " + s.charAt(0));
```

## 例子：`Set`

Java 的集合类提供了一个很好的例子，说明将接口和实现分开。

让我们以 Java 集合库中的一个 ADT `Set`为例。 `Set`是某种其他类型`E`的有限元素集的 ADT。 以下是`Set`接口的简化版本：

```java
/** A mutable set.
 *  @param <E> type of elements in the set */
public interface Set<E> {
```

`Set`是**泛型类型的**一个示例：一种类型，其指定是以后要填充的占位符类型。 我们不是为`Set<String>`、`Set<Integer>`等编写单独的规范和实现，而是设计和实现一个`Set<E>`。

我们可以将 Java 接口与我们对 ADT 操作的分类进行匹配，从创建者开始：

```java
    // example creator operation
    /** Make an empty set.
     *  @param <E> type of elements in the set
     *  @return a new set instance, initially empty */
    public static <E> Set<E> make() { ... } 
```

该`make`操作是作为静态工厂方法实现的。 客户端将编写如下代码：`Set<String> strings = Set.make();`

编译器将理解新的`Set`是`String`对象的集合。

```java
    // example observer operations

    /** Get size of the set.
     *  @return the number of elements in this set */
    public int size();

    /** Test for membership.
     *  @param e an element
     *  @return true iff this set contains e */
    public boolean contains(E e);
```

接下来，我们有两个观察者方法。 注意这些规范是如何根据我们对集合的抽象概念而言的;提及具有特定私有字段的集合的任何特定实现的细节是错误的。 这些规范应适用于集合 ADT 的任何有效实现。

```java
    // example mutator operations

    /** Modifies this set by adding e to the set.
     *  @param e element to add */
    public void add(E e);

    /** Modifies this set by removing e, if found.
     *  If e is not found in the set, has no effect.
     *  @param e element to remove */
    public void remove(E e);
```

这些赋值器的情况与观察者的情况基本相同。 我们仍然在抽象的集合模型级别上编写规范。

## Generic Interfaces（泛型接口）

（注意，通用的英文是generic，泛型的英文是generics，基本是一个单词）

假设我们想实现上面的泛型`Set<E>`接口。

方案一：**泛型接口，非泛型实现。** 我们可以做到这一点的一种方法是针对特定类型`E`实现`Set<E>`。

在 Reading 13 中，我们研究了`CharSet`。其中的样例代码包括一个通用`Set`接口，和它的每个实现`CharSet1`/`2`/`3`声明：

```java
public class CharSet implements Set<Character>
```

当接口提到占位符类型`E`时，`CharSet`实现将`E`替换为`Character` 。 例如：

```java
public interface Set<E> {

    // ...

    /**
     * Test for membership.
     * @param e an element
     * @return true iff this set contains e
     */
    public boolean contains(E e);

    /**
     * Modifies this set by adding e to the set.
     * @param e element to add
     */
    public void add(E e);

    // ...
}
```

```java
public class CharSet1 implements Set<Character> {

    private String s = "";


    // ...


    @Override
    public boolean contains(Character e) {
        checkRep();
        return s.indexOf(e) != -1;
    }

    @Override
    public void add(Character e) {
        if (!contains(e)) s += e;
        checkRep();
    }
    // ...
}
```

`CharSet1`/`2`/`3`实现的表示，并不适用于任意类型的元素。`String`的表示，如果不仔细定义处理多位数的新表示不变性和抽象函数，就不能被表示`Set<Integer>`

方案二：**泛型接口，泛型实现。** 我们也可以实现泛型`Set<E>`接口，而无需为`E`选择类型。在这种情况下，我们编写代码时对客户端将选择的实际类型视而不见。 Java 的`HashSet`为 . 它的声明看起来像这样：

```java
public interface Set<E> {

    // ...
           
```

```java
public class HashSet<E> implements Set<E> {

    // ...
     
```

泛型实现只能依赖于接口规范中包含的占位符类型的详细信息。 我们将在将来的阅读中看到`HashSet`如何依赖于 Java 中每种类型都需要实现的方法——并且只依赖于这些方法，因为它不能依赖于在任何特定类型中声明的方法。

## 为什么选择接口？

接口在实际的 Java 代码中被广泛使用。 并非每个类都与接口相关联，但是有一些很好的理由可以将接口带入视野中：

* **同时为编译器和人类作为文档**。接口不仅可以帮助编译器捕获 ADT 实现错误，而且对于人类来说，阅读起来也比具体实现的代码更有用。 此类实现将 ADT 级别的类型和规范与实现详细信息穿插在一起。
* **允许进行性能权衡**。ADT 的不同实现可以提供具有非常不同的性能特征的方法。 不同的应用程序可能在不同的选择下工作得更好，但我们希望以独立于表示的方式对这些应用程序进行编码。 从正确性的角度来看，应该可以通过简单的本地化代码更改来插入关键 ADT 的任何新实现。
* **可选方法**。`List`从 Java 标准库中将所有 mutator 方法标记为可选。 通过构建不支持这些方法的实现，我们可以提供不可变的列表。在不可变列表上，如果性能足够好，某些操作很难实现，因此我们也希望实现可变。 可以编写不调用赋值器的代码，以自动处理任何一种类型的列表。
* **故意低估规格的方法**。有限集的 ADT 可能会未指定在转换为列表时获得的元素顺序。 某些实现可能会使用较慢的方法实现，这些方法实现设法将设置的表示形式保持在某种排序顺序中，从而允许快速转换为排序列表。 其他实现可能会使许多方法更快，因为无需费心支持转换为排序列表。
* **一个类的多个视图**。一个 Java 类可以实现多种方法。 例如，显示下拉列表的用户界面小部件既可以看作是小部件，也可以看作是列表。 此小部件的类可以实现这两个接口。 换句话说，我们不会仅仅因为我们选择了不同的数据结构而多次实现 ADT;我们可能会进行多种实现，因为许多不同种类的对象也可能被视为 ADT 的特例，以及其他有用的视角。
* **越来越不值得信赖的实现**。多次实现接口的另一个原因可能是，构建一个你认为正确的简单实现很容易，而你可以更努力地构建一个更有可能包含错误的更高级的版本。 您可以根据被 bug 损害的糟糕程度来选择应用程序的实现。

## 在 Java 中实现 ADT 概念

现在，我们可以从第一个 ADT 中扩展 ADT 概念的 Java 工具箱：

| ADT概念            | 在 Java 中执行此操作的方法                                   | 例子                                                         |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Abstract data type | 单个类                                                       | `String`                                                     |
|                    | 接口 + 泛型类                                                | `List`和`ArrayList`                                          |
| Creator operation  | 构造函数（Constructor）, 静态（工厂）方法（Static (factory) method）, 常量（Constant） | `ArrayList()` `Collections.singletonList()` `Arrays.asList()` `BigInteger.ZERO` |
| Observer operation | 实例方法（Instance method）, 静态方法（Static method）       | `List.get()` `Collections.max()`                             |
| Producer operation | 实例方法（Instance method）, 静态方法（Static method）       | `String.trim()` `Collections.unmodifiableList()`             |
| Mutator operation  | 实例方法（Instance method）, 静态方法（Static method）       | `List.add()` `Collections.copy()`                            |
| Representation     | `private`字段                                                |                                                              |

# Reading 15: Equality（等价性）

## 介绍

通过创建以操作为特征的类型，而不是以表示为特征的类型，已经发展了一个严格的**数据抽象**概念。对于抽象数据类型，**抽象函数**解释了如何将具体值解释为抽象类型的值，并且我们看到了抽象函数如何决定编写是写 ADT 的每个操作的代码。

本文中，我们介绍如何定义数据类型中值**相等**的概念：抽象函数提供了清晰定义 ADT 上的相等运算的方法。

## 看待平等的三种方式

1. **使用抽象函数**。抽象函数 f: R→ A 将数据类型的具体实例映射到其对应的抽象值。为了使用 f 作为相等的定义，我们说，a 等于 b，当且仅当 f(a) = f(b)。

2. **使用关系**。等价是关系 E ⊆ T x T，即：

   1. 自反性（reflexive）：E(t,t) ∀ t ∈ T
   2. 对称性（sysmmetric）：E(t,u) ⇒ E(u,t)
   3. 传递性（transitive）：E(t,u) ∧ E(u,v) ⇒ E(t,v)

   为了使用 E 作为相等的定义，我们说 a 等于 b，当且仅当 E(a,b)。

3. **使用观察者操作**。根据局外人（客户）可以观察到的关于它们的内容。当两个物体无法通过观察来区分时，我们可以说它们是相等的——我们可以应用的每个操作都会为两个物体产生相同的结果。例如集合{1,2}和{2,1}，对于观察者操作，基数操作`...`和成员操作`∈`，都无法区分。于是我们认为它们相等。

注意，这三种方式，在实践中应当是等价的。

### 示例：持续时间 Duration

```java
public class Duration {
    private final int mins;
    private final int secs;
    // rep invariant:
    //    mins >= 0, secs >= 0
    // abstraction function:
    //    represents a span of time of mins minutes and secs seconds

    /** Make a duration lasting for m minutes and s seconds. */
    public Duration(int m, int s) {
        mins = m; secs = s;
    }
    /** @return length of this duration in seconds */
    public long getLength() {
        return mins*60 + secs;
    }
}
```

下面哪些值是等价的？

```java
Duration d1 = new Duration (1, 2);
Duration d2 = new Duration (1, 3);
Duration d3 = new Duration (0, 62);
Duration d4 = new Duration (1, 2);
```

## == 与 equal()

Java 有两种不同的操作来测试相等性，但语义不同。

* `==`运算符比较引用。更准确地说，它测试的是**引用**相等性。如果两个引用指向内存中的同一存储，则它们为 ==。就我们一直在绘制的快照图而言，如果它们的箭头指向同一对象气泡，则这两个引用`==`。
* `equals()`操作比较对象内容 - 换句话说， **对象**相等，这就是我们在本阅读中一直在讨论的意义上。必须为每种抽象数据类型适当定义等于运算。

几种语言中的比较操作：

|             | 引用相等 | 对象相等   |
| ----------- | -------- | ---------- |
| Java        | `==`     | `equals()` |
| Objective C | `==`     | `isEqual:` |
| C#          | `==`     | `Equals()` |
| Python      | `is`     | `==`       |
| Javascript  | `==`     | n/a        |

## 不可变类型的等价性

`equals()`方法由基类`Object`定义，默认定义如下：

```java
public class Object {
    ...
    public boolean equals(Object that) {
        return this == that;
    }
}
```

两者含义相同，这肯定不对。因为我们必须**重写**`equals()`方法。

我们的第一次尝试：

```java
public class Duration {
    ...   
    // Problematic definition of equals()
    public boolean equals(Duration that) {
        return this.getLength() == that.getLength();        
    }
}
```

尝试运行下面这段代码：

```java
Duration d1 = new Duration (1, 2);
Duration d2 = new Duration (1, 2);
Object o2 = d2;
d1.equals(d2) → true
d1.equals(o2) → false
```

这是因为虽然`Duration`的方法`equals()`进行了**重载**，但由于方法签名不同，实际上有两种方法：一种是隐式的`euqals(Object)`继承自`Object`，另一个是新的`equals(Duration)`。

具体来说，就是下面这样：

```java
public class Duration extends Object {
    // explicit method that we declared:
    public boolean equals (Duration that) {
        return this.getLength() == that.getLength();
    }
    // implicit method inherited from Object:
    public boolean equals (Object that) {
        return this == that;
    }
}
```

实际上，在第一课静态检查中，就有重载出现。例如`/`运算符，会根据后面的数字是`float`还是`int`，使用不同的计算方式。这一步由编译器进行处理。

当我们传递`Object`引用时，就像在`d1.equals(o2)`中，实际调用的是`equals(Object)`的实现。当我们传递`Duration`引用时，就像在`d1.equals(d2)`中，实际调用的是`equals(Duration)`版本。即使`o2`和`d2`在运行时实际指向同一个对象，等价性已经发生了改变。

由于在方法签名中很容易犯错，这是一个常见的错误。所以 Java 有个语言特性，注解`@Overrive`，当你重写父类中的方法时，应该使用这个注解。这样 Java 编译器将会检查父类中是否存在相同签名的方法。

所以，`Duration`正确`equals()`的实现方式如下：

```java
@Override
public boolean equals (Object thatObject) {
    if (!(thatObject instanceof Duration)) return false;
    Duration thatDuration = (Duration) thatObject;
    return this.getLength() == thatDuration.getLength();
}
```

这样的结果如下：

```java
Duration d1 = new Duration(1, 2);
Duration d2 = new Duration(1, 2);
Object o2 = d2;
d1.equals(d2) → true
d1.equals(o2) → true
```

### `instanceof`运算符

注意，`instanceof`运算符测试对象是否为特定类型的实例，这是一个动态类型检查，而我们提倡使用静态类型检查。因此，**除了实现`euqals`之外，`instanceof`在其他任何地方都是不允许的**。同理，类似的，`getClass`也是不允许的。

## Object的约定

`Object`类的规范非常重要。这里我们重点介绍`equals`的约定。当重写`Object`的`equals`方法时，需要遵守一般约定：

* `equals`必须定义一个等价关系——即自反、对称和传递的关系。
* `equals`必须一致：对`equals`方法的重复调用必须产生相同的结果。
* 对于非 null 引用`x`，`x.equals(null)`应返回 false。
* 对于`equals`方法认为等价的对象，`hashCode`必须产生相同的结果。

### 打破等价关系

不满足等价关系，即违背了自反性、对称性或传递性。观察如下例子：

```java
private static final int CLOCK_SKEW = 5; // seconds

@Override
public boolean equals (Object thatObject) {
    if (!(thatObject instanceof Duration)) return false;
    Duration thatDuration = (Duration) thatObject;
    return Math.abs(this.getLength() - thatDuration.getLength()) <= CLOCK_SKEW;
}
```

### 打破哈希表

哈希表的 rep 不变性包括键位于由其哈希代码确定的插槽中的基本约束。

如果两个相等的对象具有不同的哈希码，它们可能会被放置在不同的插槽中。因此，如果尝试使用与插入值时相等的键来查找值，则查找可能会失败。

`Object`的默认`hashCode()`实现和默认`equals()`实现一致：

```java
public class Object {
  ...
  public boolean equals(Object that) { return this == that; }
  public int hashCode() { return /* the memory address of this */; }
}
```

这是满足约定的。

但不可变对象`Duration`需要不同的实现，由于我们对`Object`没有重写`hashCode()`，所以我们已经破坏了约定。

```java
Duration d1 = new Duration(1, 2);
Duration d2 = new Duration(1, 2);
d1.equals(d2) → true
d1.hashCode() → 2392
d2.hashCode() → 4823
```

一个很简单的想法是，返回一个常量。这确实满足了约定的要求，但在哈希表中的性能会大大受到影响，所有键都将存储到一个插槽里，每次查找都退化为线性搜索。

一个更合理的方案是，为对象的每个组件计算一个哈希值，然后加入一些运算组合起来。

即使是性能不佳的哈希函数，也比破坏约定的哈希函数要好。

不重写，肯定是错的。

> 当你重写`equals`时，总是重写`hashCode`。

## 可变对象的等价性

回想定义：当两个物体无法通过观察来区分时，它们是相等的。对于可变对象，有两种方法可以解释这一点：

* 当无法通过不改变对象状态的观察方法来区分时，即即通过调用观察者、生产者和创造者方法。这被严格称为**观察等价性**。因为它们看起来相同。
* 当无法通过任何观察方法来区分时，甚至状态发生变化。包括使用赋值器方法。这被称为**行为等价性**。因为它们在当前状态和未来状态都相同。

对于不可变对象，观察等价性和行为等价性时相同的，因为它们没有赋值器方法。

对于可变对象，严格的观察等价性很诱人。事实上，Java 中大多可变数据类型确实都使用观察等价性。例如两个不对的对象包含相同的元素序列，则报告它们是等价的。

但使用观察等价性，也会导致一些错误，实际上，我们可以打破其他集合数据结构的 rep 不变量。假设我们创建一个`List`，然后将其放入`Set`：

```java
List<String> list = new ArrayList<>();
list.add("a");

Set<List<String>> set = new HashSet<List<String>>();
set.add(list);
```

我们可以检查该集合是否包含我们放入其中的列表，并且它确实包含：

```java
set.contains(list) → true
```

然后我们改变列表：

```java
list.add("goodbye");
```

则它不再出现在集合中：

```java
set.contains(list) → false
```

更糟糕的是：当我们遍历集合的成员时，我们仍然在那里找到列表，但`contains()`说它不在那里！

```java
for (List<String> l : set) { 
    set.contains(l) → false! 
}
```

如果集合自己的迭代器和它自己的方法`contains()`在元素是否在集合中存在分歧，那么集合显然是被破坏的。

原因是这样的：`List<String>`是一个可变对象，在类似`List`这样的集合类的标准 Java 实现中，值的变化会影响`equals()`和`hashCode()`的结果。当`List`首次放入`HashSet`时，它被存储在与当时结果对应的 hash 桶中。当 `List`随后发生值的变化，它的`hashCode()`也发生变化，但却并没有将其移动到不同的插槽中，所以再也找不到了。

当`equals()`和`hashCode()`可能受到值的变化的影响时，我们可以打破哈希表将对象作为键的 rep 不变性。

这是关于`java.util.Set`的一个重要规范：

> 注意：当可变对象作为`Set`的元素时，要非常小心。如果对象的值以影响等价的方式发生改变，而对象是`Set`中的元素，则不会指定`Set`的行为。

不幸的是，Java 库对可变类`equals()`的解释不一致。`Set`使用观察等价，但其他可变类（如`StringBuilder`）使用行为等价。

从这个例子中，我们得到的教训是`equals()`**应该实现行为等价**。通常，这意味着当且仅当两个引用是同一对象的别名时，它们才应为两个引用`equals()`。所以可变对象应该只是继承`equals()`和从`Object`的`hashCode()`。对于需要观察相等概念的客户（两个可变对象在当前状态下是否“看起来”相同），最好定义一个新方法，例如`similar()`。

## equals() 和 hashCode() 的最终规则

**对于不可变类型** ：

- `equals()`应该比较抽象值。这与`equals()`说应该提供行为等价性是一样的。
- `hashCode()`应将抽象值映射到整数。

因此，不可变类型必须覆盖`equals()`和`hashCode()`。

**对于可变类型** ：

- `equals()`应该比较引用，就像`==`。同样，这与`equals()`说应该提供行为等价性是一样的。
- `hashCode()`应将引用映射为整数。

因此，可变类型不应覆盖`equals()`和`hashCode()`，而应仅使用`Object`提供的默认实现。不幸的是，Java 在其集合中没有遵循此规则，这导致了我们上面看到的陷阱。

### 自动封装和等价性

Java 中还有一个具有指导意义的陷阱。我们已经讨论了基元类型及其对象类型等效物，例如`int`和`Integer`。对象类型以正确的方式实现`equals()`，因此，如果创建两个具有相同值的`Integer`对象，它们将相互满足`equals()`：

```java
Integer x = new Integer(3);
Integer y = new Integer(3);
x.equals(y) → true
```

但是有个小问题：重载`==`。对于`Integer`这样的引用类型，它实现了引用相等：

```java
x == y // returns false
```

但是对于像`int`这样的原始类型，`==`实现了行为相等：

```java
(int)x == (int)y // returns true
```

所以你不能真的将`Integer`与`int`互换使用。事实上，Java会自动在`Integer`和`int`之间转换（这称为**autoboxing（自动封装）**和**autounboxing（自动解封装）** ），这可能会导致一些微妙的错误！您必须知道表达式的编译时类型是什么。考虑一下：

```java
Map<String, Integer> a = new HashMap(), b = new HashMap();
a.put("c", 130); // put ints into the map
b.put("c", 130);
a.get("c") == b.get("c") → ?? // what do we get out of the map?
```

## 总结

- 相等应该是一种等价关系（自反的、对称的、传递的）。
- 相等和哈希值必须彼此一致，以便使用哈希表（像`HashSet`和`HashMap`）的数据结构能够正常工作。
- 抽象函数是不可变数据类型中相等的基础。
- 引用相等是可变数据类型中相等的基础：这是确保一段时间内的一致性并避免破坏哈希表的 rep 不变量的唯一方法。

# Reading 16: Recursive Data Types（递归数据类型）

## Part 1: Recursive Data Types（递归数据类型）

## 递归函数

正如递归函数是根据自身定义的一样，**递归数据类型**也是根据自身定义的。 我们将看到对**基本**情况和**递归**情况的相同需求，它们现在将作为抽象类型的不同**变体**出现。

## Imutable lists（不可变列表）

我们从一个经典的递归数据类型开始，即不可变列表。

不变性之所以强大，不仅因为它的安全性，还因为它具有共享的潜力。 共享实际上可以带来性能优势：消耗的内存更少，复制所花费的时间更少。 在这里，我们将了解如何以不同于我们熟悉的数组列表或链表的方式表示列表数据结构。

为不可变列表列表`ImList<E>`定义数据类型。数据类型有四个基本操作：

| 操作                          | 返回值                                           |
| ----------------------------- | ------------------------------------------------ |
| **empty: void → ImList**      | 一个空列表                                       |
| **cons: E × ImList → ImList** | 在原列表前插入一个元素的新列表                   |
| **first: ImList → E**         | 列表的第一个元素（要求列表不为空）               |
| **rest: ImList → ImList**     | 列表中除了第一个元素形成的列表（要求列表不为空） |

它们在函数式编程中被广泛使用，在那里你经常可以找到它们被称为 head 和 tail，而不是 *first* 和 *rest* 。

## Java 中的不可变类型

为了在 Java 中实现该数据类型，我们使用一个接口：

```java
public interface ImList<E> {
    // TODO: ImList<E> empty()
    public ImList<E> cons(E e);
    public E first();
    public ImList<E> rest();
}
```

编写两个实现此接口的类：

```java
public class Empty<E> implements ImList<E> {
    public Empty() {
    }
    public ImList<E> cons(E e) {
        return new Cons<>(e, this);
    }
    public E first() {
        throw new UnsupportedOperationException();
    }
    public ImList<E> rest() {
        throw new UnsupportedOperationException();
    }
}
```

```java
public class Cons<E> implements ImList<E> {
    private final E e;
    private final ImList<E> rest;

    public Cons(E e, ImList<E> rest) {
        this.e = e;
        this.rest = rest;
    }
    public ImList<E> cons(E e) {
        return new Cons<>(e, this);
    }
    public E first() {
        return e;
    }
    public ImList<E> rest() {
        return rest;
    }
}
```

这种实现方式，有`cons`、`first`和`rest`方法，但`empty`方法呢？

一种实现`empty`的方式是客户端调用`Empty`类构造函数来获取空列表。但这样就丧失了表示的独立性——客户必须了解`Empty`类。

正如接口一讲所言，更好的方法是作为一种静态工厂方法，不带任何参数并生成一个`Empty`的实例。我们可以将静态方法放在`ImList`接口中，注意这在早期 Java 版本中是不可能的。于是，我们可以使用如下代码：

```java
List<String> z = new ArrayList<>();
```

也许日后 Java 会推出`List.empry()`方法来获取空`List`，但现在还没有。

更新`ImList`接口后的代码如下：

```java
public interface ImList<E> {
    public static <E> ImList<E> empty() {
        return new Empty<>();    // 这里因为是静态函数，无法得知E的具体类型，所以不写，自动填充
    }
    public ImList<E> cons(E e);
    public E first();
    public ImList<E> rest();
}
```

现在我们就有了所有的操作。

### 两个类实现一个接口

此设计与我们看到的`List`、`ArrayList`和`LinkedList`不同。`List`是抽象数据类型，`ArrayList`和`LinkedList`是该数据类型的两种可替换的具体表现形式。

对于`ImList`，是通过`Empty`和`Cons`合作来实现的数据类型。

## Recursive datatype definitions（递归数据类型定义）

抽象数据类型`ImList`及其两个具体类`Empty`和`Cons`构成了递归数据类型。`Cons`是`ImList`的实现，但它在自己内部的表示（`rest`字段）中也用到了`ImList`，所以这就递归地要求`ImList`的实现才能成功完成约定。

把这个现象说的更明白些，如下**数据类型定义**：

```java
ImList<E> = Empty + Cons(first:E, rset:ImList)
```

这是作为一组值的递归定义。集合`ImList`由以两种方式形成的值组成：通过构造函数`Empty`，或者通过将构造函数`Cons`应用于一个元素和一个`ImList`而形成。通过这样描述，数据类型的递归特性会更加明显。

我们也可以用此定义将`ImList`值编写为术语或表达式，例如：

```java
Cons(0, Cons(1, Cons(2, Empty)))
```

从形式上讲，数据类型定义具有：

* 左边是**抽象数据类型**，右边由其**表示**形式（或**具体数据类型**）定义
* 该表示形式由以**+**分割的数据类型的**变体**组成
* 每个变体都是一个构造函数，具有零个或多个命名（和类型化）参数

另一个例子是二叉树：

```java
Tree<E> = Empty + Node(e:E, left:Tree<E>, right:Tree<E>)
```

## 递归数据类型上的函数

这种思考方式，具有具体变体的抽象数据类型的递归定义，很有吸引力。不仅因为它可以处理递归和无界结构，如列表和树，还因为它提供了一种方便的方式来描述对数据类型的操作，作为每个变体都有不同处理方式。

例如，考虑列表的大小，这是在`ImList`中执行的操作。我们这样定义：

**size : ImList → int** // 返回列表的规模

然后通过定义`ImList`的每个变体的大小来完全指定其含义：

> size(Empty) = 0
>
> size(Cons(first: E, rest: ImList)) = 1 + size(rest)

这个函数是递归的。于是我们可以将特定列表上的规模执行视为一系列减少步骤。

定义中的情况可以直接转化为 Java 中的`ImList`，`Empty`和`Cons`中方法：

```java
public interface ImList<E> {
    // ...
    public int size();
}

public class Empty<E> implements ImList<E> {
    // ...
    public int size() { return 0; }
}

public class Cons<E> implements ImList<E> {
    // ...
    public int size() { return 1 + rest.size(); }
}
```

这种通过以下方法对递归数据类型实现操作的模型

* 在抽象数据类型接口中**声明**操作
* 在每个具体变体中（递归）**实现**操作

是一种非常常见的设计模型。它被称为解释器模型（对理解毫无帮助）。

其他的一些函数，也可以同样实现：

**isEmpty : ImList → boolean**

**contains : ImList × E → boolean**

**get: ImList × int → E**

**append: ImList × ImList → ImList**

**reverse: ImList → ImList**

## 调整表示

获取列表大小是一种常见操作。我们之前的实现需要 O(n) 时间完成，其中，n 是列表的长度。我们可以通过缓存来优化到 O(1)。

```java
public class Cons<E> implements ImList<E> {
    private final E e;
    private final ImList<E> rest;
    private int size = 0;
    // rep invariant:
    //   e != null, rest != null, size >= 0
    //   size > 0 implies size == 1+rest.size()

    // ...
    public int size() { 
        if (size == 0) size = 1 + rest.size();
        return size;
    }
}
```

注意，我们用特殊值 0 来表示尚未计算。这个更改为表示不变量引入了一个新子句，将`size`字段和`rest`字段相关联。

这是一个有趣的事：这是一个不可变的数据类型，但有一个可变的表示。它正在修改自己的 size 字段。这是一个**有益突变**的例子。这种状态变换，不会改变对象所表示的抽象值，因此类型依然是不可变的。

### 重新审视表示独立性和表示暴露

**表示独立性**：`ImList`的 java 实现中，我们在静态方法`ImList.emptyJ()`中隐藏了构造函数`Empty`，客户端永远不需要直接使用`Empty`或`Cons`构造函数。我们可以通过使它们成为包私有（既不用`private`，也不用`public`关键字来声明），这样，`ImList`所在之外的包就不能看到或使用它们。

我们由很大自由度来实现。比如，我们刚才添加的`size`字段作为`Cons`的内部表示。我们甚至可以用额外数组使`get()`运行更快，不过在空间上有些浪费。但我们可以自由修改。

**表示暴露**：`Cons.rest()`会返回一个自身内部的列表的引用，客户可能向其中添加元素吗？如果添加，会威胁到两个`Cons`的不变量：然而一个是不可修改的，另一个是缓存字段`size`，则永远是正确的（只有观察者可以修改，没有自由赋值方式）。所以是没有表示暴露的风险的。

## Null vs. empty

不用`Empty`，而使用`null`，看起来很诱人，但不能这么做。

使用对象（而不是空引用）来表示数据结构的基本情况或顶点，是称为**哨兵模式（Sentinel Objects）**的一种设计模式示例。哨兵对象提供的巨大优势是它的行为类似于数据类型中的对象，因此您可以对它调用方法。于是，我们甚至可以在空列表上调用`size()`方法。而如果用`null`来表示，则永远无法做到这一点，进而会导致代码中充满判断测试的语句，如下：

```java
if (lst != null) n = lst.size();
```

这使得代码杂乱无章，模糊其含义，并且容易忘记。更好的办法当然是：

```java
n = lst.size();
```

这将使用有效，包括`lst`指向的是`Empty`对象。

将`null`排除在你的数据结构外，你的生活会更快乐。

## 声明类型与实际类型

现在我们已经使用了接口和类，强调一下 Java 的类型检查时如何工作的一个重要观点。事实上，每一种静态检查的面向对象语言都是这么工作的。

类型检查有两个方面：程序运行前的**编译时间**和程序执行时的运行时间。

在编译时，每个变量都有一个**声明类型**，在其声明中被声明。编译器使用已声明的变量类型（和方法返回值）来推断程序中每个表达式的声明类型。

在运行时，每个对象都有一个**实际类型**，由创建对象的构造函数注入其中。例如，`new String()`创建一个实际类型为`String`的对象。`new Empty()`创建一个实际类型为`Empty`的对象。而`new ImList()`则被 Java 禁止，因为`ImList`是一个接口——它没有自己的对象值，也没有构造函数。

## 另一个例子：布尔公式（Boolean formulas）

计算机科学中另一种有用的递归数据类型是布尔公式。 例如，这里有一个命题逻辑的公式：

> (P [∨ ](https://en.wikipedia.org/wiki/Logical_disjunction)Q) [∧ ](https://en.wikipedia.org/wiki/Logical_conjunction)( [¬ ](https://en.wikipedia.org/wiki/Logical_negation)P [∨ ](https://en.wikipedia.org/wiki/Logical_disjunction)R)

这意味着“P 或 Q 为 *真，P* 为假或 R 为真”。

我们可以给出一个数据类型定义，适合表示命题逻辑的所有公式。

```java
Formula = Variable(name:String)
          + Not(formula:Formula)
          + And(left:Formula, right:Formula)
          + Or(left:Formula, right:Formula)
```

*(P ∨ Q) ∧ (¬P ∨ R)* 为

```java
And( Or(Variable("P"), Variable("Q")),
     Or(Not(Variable("P")), Variable("R")) )
```

布尔公式的一个关键操作是测试它们是否*令人满意* ，即，对变量的真/假值赋值是否会导致公式的计算结果为真。 有一个简单但缓慢的算法来检查满足性：

1. 从公式中提取变量集。
   我们已经通过**variables**操作实现了这一点。
2. 尝试为这些变量赋值的所有可能的真/假值。
   我们可以通过用`Environment`（变量及其值形成的列表）来表示赋值过程。 我们可以用`ImList`来实现`Environment`，或者开发一个不可变的映射类型。
3. 评估每个环境的公式。
   为此，我们将定义 **evaluate ： Formula × Environment → Boolean** 。
4. 返回公式计算结果为 true 的第一个环境。

定义这些部分并将它们组合成一个**令人满意的 ： 公式 → 布尔**函数是另一个时间的练习。

### 具有不变性的回溯搜索（Backtracking search with immutability）

我们从不可变列表开始阅读这部分，这些列表是一种表示形式，允许在不同的列表实例之间进行大量共享。 但是，一种特定类型的共享：实际上只能共享列表的末尾。 如果两个列表在开始时相同，但后来彼此不同，则必须单独存储它们。 （为什么？）

事实证明，回溯搜索对于这些列表来说是一个很好的应用，原因如下。 在空间中的搜索（就像对一组布尔变量的赋值空间一样）通常是通过一个接一个的选择来进行的，当一个选择导致死胡同时，你就会回溯。

可变数据结构通常不是回溯的好方法。 例如，如果您使用可变类型的`Map`来跟踪您正在尝试的当前变量绑定，那么每次回溯时都必须撤消这些绑定。 与处理不可变映射相比，这很容易出错，而且很痛苦——当你回溯时，你就会把映射扔掉！

但是，没有共享的不可变数据结构也不是一个好主意，因为如果你每次采取新的步骤都必须制作一个完整的副本，那么你需要跟踪你所处位置的空间（在满足性问题的情况下，环境）将二次增长。 您需要保留路径上的所有先前环境，以防需要备份。

不可变列表具有一个很好的属性，即在路径上执行的每个步骤都可以共享前一步的所有信息，只需添加到列表的前面即可。 当您必须回溯时，您将停止使用当前步骤的状态，但您仍然可以引用上一步的状态。

最后，使用不可变数据结构的搜索可以立即进行并行化。 您可以委托多个处理器一次搜索多个路径，而不必处理它们在共享可变数据结构中相互踩踏的问题。 当我们谈到并发性时，我们将更多地讨论这个问题。

## 总结

除了**递归数据类型**的大概念之外，我们还在这篇阅读中看到：

- **数据类型定义**：一种思考抽象类型（尤其是递归类型）的强大方法
- **递归数据类型上的函数**：在类型的规范中声明，并为每个具体变体实现一个特定的方法
- 不可变列表：不可变数据类型的经典规范示例

## Part 2: Writing a Program with Abstract Data Types（通过抽象数据类型来编写程序）

## 编程秘诀

回想一下测试优先的编程方法的**编写过程**（静态方法）：

1. **规范**。编写规范，包括方法签名（名称、参数类型、返回类型、异常）以前置条件和后置条件作为 Javadoc 注释。
2. **测试**。创建系统的测试用例，并将它们放在 JUnit 类中，以便你可以自动运行它们。
   1. 当你开始编写测试用例的时候，可能需要返回并更改第1步制定的规范。仅仅编写测试用例的过程就会给规范带来压力，因为你正在考虑客户端会如何调用该方法。因此，第1步和第2步会进行迭代，直到获得更好的规范和一些好的测试用例。
   2. 确保至少一些测试一开始是失败的。一份测试套件如果在你还没有开始实现方法的时候，就能通过所有的测试，那么这不是一份好的能找到 bug 的测试套件。
3. **实现**。编写方法的主体。当 JUnit 中的测试全部都为绿色时，就说明完成了。
   1. 实现方法可能会给测试和规范带来压力，你可能会发现其中的错误，必须返回并修复这些错误。因此，完成这项工作可能需要更改实现、测试和规范，并在它们之间来回切换。

接下来扩展到**编写抽象数据类型**：

1. **规范**。为数据类型的操作编写规范，包括方法签名、前置条件和后置条件。
2. **测试**。为 ADT 的操作编写测试用例。
   1. 同样，这给规范带来了压力。你可能会发现需要没有预料到的操作，因此必须将它们加入到规范中。
3. **实现**。对于 ADT ，此部分的扩展为：
   1. **选择表示**。记下类的私有字段，或递归数据类型的变体。 将 rep 不变量写下作为注释。
   2. **断言表示不变性**。实现`checkRep()`强制执行 rep 不变性的方法。 如果 rep 不变性是非平凡的，这一点至关重要，因为它会更早地捕获 bug。
   3. **实现操作**。编写操作的方法主体，确保它们调用`checkRep()`。当 JUnit 中的测试全部为绿色时，您就完成了。

再接下扩展到**编写一段程序**（同时包括ADT和过程）：

1. **选择数据类型**。决定哪些是可变的，哪些是不可变的。
2. **选择过程**。编写顶级过程，并将其分解为较小的步骤。
3. **规范**。详细说明 ADT 和程序。 首先保持 ADT 操作简单且很少。 仅在需要时添加复杂操作。
4. **测试**。为每个单元（ADT 或过程）编写测试用例。
5. **快速简单实现**。选择简单的暴力表示形式。 这里的关键是给规格和测试施加压力，并尝试尽快将整个程序放在一起。 首先使整个程序正常工作。 暂时跳过高级功能。 跳过性能优化。 跳过极端情况。 保留一份待办事项清单，列出您必须重新审视的内容。
6. **重新实现、迭代和优化**。现在一切都在工作，让它工作得更好。

## 问题：矩阵乘法（matrix multiplication）

假设我们想计算矩阵乘法，并且我们想更快地完成它们。

例如，如果 *a* 、 *b* 是标量常数，*X* 是大矩阵，则

> *(aX)b*

计算速度很慢，因为它在矩阵 *X* 上循环两次：一次是将其乘以 *a* ，然后再次将其乘以 *b* 。 这样做是等效的，而且成本更低：

> *(ab)X*

这只是我们可以通过在矩阵乘法中重新排列乘积来进行的优化的一个例子。 （但请记住，矩阵乘法是关联的，但不是交换的;只有标量是交换的。

### 选择数据类型

我们将其称为`MatrixExpression`。为了使定义更易于阅读，我们将其缩写为`MatExpr`。

让我们定义一些操作：

**make**：double → MatExpr
// 效果：返回一个仅由给定标量组成的表达式

**make**：double\[\]\[\] → MatExpr
// 要求：对于所有 i，array.length > 0，且 array[i].lengths 相等且> 0
// 效果：返回仅由给定矩阵组成的表达式



**times**：MatExpr × MatExpr → MatExpr
// 要求：m1 和 m2 兼容乘法
// 效果：返回 m1×m2



**isIdentity**：MatExpr → boolean
// 效果：如果表达式是乘法恒等式（在代数结构中，存在一个元素满足对于任意一个元素a，都有a \* 1 = a的性质，这里即单位矩阵或1），则返回真

而我们真正想要的那个：

**optimize**：MatExpr → MatExpr
// 效果：返回一个具有相同值的表达式，但计算速度可能更快

### 测试

我们来测试一下`optimize()`。分区：

- 表达式中的标量数：0、1、2、>2
- 标量在表达式树中的位置：表达式树的直接左侧（immediate left）、表达式树的直接右侧（immediate right）、表达式树的左侧的左侧（left-of-left）、表达式树的左侧的右侧（left-of-right）、表达式树的右侧的左侧（right-of-left）、表达式树的右侧的右侧（right-of-right）

| 测试用例              | 覆盖的分区                       |
| --------------------- | -------------------------------- |
| X ⇒ X                 | 0 标量                           |
| aX ⇒ aX               | 1 标量，直接左侧                 |
| a(Xb) ⇒ (ab)X         | 2 个标量，直接左侧，右侧的右侧   |
| (aX)b ⇒ (ab)X         | 2 个标量，直接右侧，左侧的左侧   |
| (Xa)(bY) ⇒ (((ab)X)Y) | 2 个标量，左侧的右侧，右侧的左侧 |

### 选择表示

这个问题是天然的递归数据类型。

> MatExpr = Identity + Scalar(double) + Matrix(double\[\]\[\]) + Product(MatExpr, MatExpr)

```java
/** Represents an immutable expression of matrix and scalar products. */
public interface MatrixExpression {
    // ...
}

class Identity implements MatrixExpression {
    public Identity() {
    }
}

class Scalar implements MatrixExpression {
    private final double value;
    public Scalar(double value) {
        this.value = value;
    }
}

class Matrix implements MatrixExpression {
    private final double[][] array;
    // RI: array.length > 0, and all array[i] are equal nonzero length
    public Matrix(double[][] array) {
        this.array = array; // note: danger!
    }
}

class Product implements MatrixExpression {
    private final MatrixExpression m1;
    private final MatrixExpression m2;
    // RI: m1's column count == m2's row count, or m1 or m2 is scalar
    public Product(MatrixExpression m1, MatrixExpression m2) {
        this.m1 = m1;
        this.m2 = m2;
    }
}
```

### 选择单位元

在数据类型中有一个不表示任何内容的值总是好的，这样我们就可以避免使用`null`。对于矩阵产品，自然的选择是恒等矩阵——无论如何，空的乘积表达式就是恒等式。 因此，让我们定义一下：

```java
/** Identity for all matrix computations. */
public static final MatrixExpression I = new Identity();
```

不幸的是，我们将看到这不是一个完美的情况：其他 MatExprs 也可能是单位元。

### 实现`make`：使用工厂方法

我们开始实现`make`，从创造者开始：

我们不想公开我们的具体代表类`Scalar`、`Matrix`和`Product`，这样客户就不会依赖它们，我们以后也能够更好地修改它们。

因此，我们将在`MatrixExpression`中创建静态方法来实现`make()`：

```java
/** @return a matrix expression consisting of just the scalar value */
public static MatrixExpression make(double value) {
    return new Scalar(value);
}

/** @return a matrix expression consisting of just the matrix given */
public static MatrixExpression make(double[][] array) {
    return new Matrix(array);
}
```

这些方法称为**工厂方法** ，即扮演构造函数角色的静态方法。 工厂方法模式是一种常见的设计模式，您将在面向对象的编程中看到，很多语言都是这样。

### 实现`isIdentity`：不要使用`instanceof`

现在来实现`isIdentity`观察者。这是一个**糟糕**的方式：

```java
// don't do this
public static boolean isIdentity(MatrixExpression m) {
    if (m instanceof Scalar) {
        return ((Scalar)m).value == 1;
    } else if (m instanceof Matrix) {
        // ... check for 1s on the diagonal and 0s everywhere else
    } else ... // do the right thing for other variant classes
}
```

一般来说，在面向对象编程中，使用`instanceof`是一种坏习惯。将操作分解为适合每个类的部分，并改为编写实例方法：

```java
class Identity implements MatrixExpression {
    public boolean isIdentity() { return true; }
}

class Scalar implements MatrixExpression {
    public boolean isIdentity() { return value == 1; }
}

class Matrix implements MatrixExpression {
    public boolean isIdentity() { 
        for (int row = 0; row < array.length; row++) {
            for (int col = 0; col < array[row].length; col++) {
                double expected = (row == col) ? 1 : 0;
                if (array[row][col] != expected) return false;
            }
        }
        return true;
    }
}

class Product implements MatrixExpression {
    public boolean isIdentity() { 
        return m1.isIdentity() && m2.isIdentity();
    }
}
```

实现`isIdentity()`暴露了一个我们应该首先通过编写测试用例来发现的问题：当`Product`的值是单位矩阵（如A × A^-1^）的时候，我们不会总是返回`true`。我们可能希望通过削弱`isIdentity`的规范来解决这个问题。

### 不使用`instanceof`来实现`optimize`

让我们实现`optimize()`。同样，这是一个**糟糕**的方法：

```java
// don't do this
class Product implements MatrixExpression {
    public MatrixExpression optimize() {
        if (m1 instanceof Scalar) {
            ...
        } else if (m2 instanceof Scalar) {
            ...
        }
        ...
}
```

如果你发现自己在编写代码时到处都是`instanceof`检查，你需要退后一步，重新思考这个问题。

特别的，为了优化标量，我们将需要两个递归帮助程序操作，因此我们将将它们添加到我们的抽象数据类型中：

**标量**：MatExpr → MatExpr
// 效果：返回一个没有矩阵的 MatExpr，只有标量

**矩阵**：MatExpr → MatExpr
// 效果：返回一个没有标量的 MatExpr，只有矩阵在输入表达式中出现的顺序相同

这些表达式将允许我们从表达式中提取标量，并将它们一起移动到一个乘法表达式中。

```java
/** Represents an immutable expression of matrix and scalar products. */
public interface MatrixExpression {

    // ...

    /** @return the product of all the scalars in this expression */
    public MatrixExpression scalars();

    /** @return the product of all the matrices in this expression.
     * times(scalars(), matrices()) is equivalent to this expression. */
    public MatrixExpression matrices();
}
```

现在，我们将按预期实现它们：

```java
class Identity implements MatrixExpression {
    public MatrixExpression scalars() { return this; }
    public MatrixExpression matrices() { return this; }
}

class Scalar implements MatrixExpression {
    public MatrixExpression scalars() { return this; }
    public MatrixExpression matrices() { return I; }
}

class Matrix implements MatrixExpression {
    public MatrixExpression scalars() { return I; }
    public MatrixExpression matrices() { return this; }
}

class Product implements MatrixExpression {
    public MatrixExpression scalars() {
        return times(m1.scalars(), m2.scalars());
    }
    public MatrixExpression matrices() {
        return times(m1.matrices(), m2.matrices());
    }
}
```

使用这些辅助函数，`optimize()`只需分离标量和矩阵：

```java
class Identity implements MatrixExpression {
    public MatrixExpression optimize() { return this; }
}

class Scalar implements MatrixExpression {
    public MatrixExpression optimize() { return this; }
}

class Matrix implements MatrixExpression {
    public MatrixExpression optimize() { return this; }
}

class Product implements MatrixExpression {
    public MatrixExpression optimize() {
        return times(scalars(), matrices());
    }
}
```

# Reading 17: Regular Expressions & Grammars（正则表达式和语法）

## 介绍

本章包含以下内容：

* 语法，包括产生式（productions）、非端点（nonterminals）、端点（terminals）和运算符（operators）
* 正则表达式
* 解析生成器

一些程序模块以**字节序列**或**字符序列**的形式接收输入或产生输出，当它简单地存储在内存中时称为**字符串**，当它流入或流出模块时，它被称为**流**。在今天的阅读中，我们将讨论如何为这样的序列编写规范。具体来说，字节或字符序列可能是：

- 磁盘上的文件，在这种情况下，规范称为**文件格式**
- 通过网络发送的消息，在这种情况下，规范是**wire传输协议**
- 用户在控制台上键入的命令，在本例中，规范是**命令行界面**
- 存储在内存中的字符串

对于这类序列，我们引入了**语法**的概念 ，它不仅使我们能够区分合法序列和非法序列，而且还可以将序列解析为程序可以使用的数据结构。由语法生成的数据结构通常会是递归数据类型。

## 语法

**语法**是描述一系列符号的紧凑表示。**语法**定义了一组句子，其中每个**句子（sequence）**都是一系列符号。

句子中的符号被称为**端点（terminals）**或**令牌（tokens）**。叫端点是因为它们是代表句子结构的树叶。通常用引号写端点，例如`'http'`。

语法中的产生式具有以下定义：

> nonterminal ::= expression of terminals, nonterminals, and operators

我们将使用小写标识符命名非终端，例如`x`或`url`。

语法的非端点之一被指定为`root`（根），语法识别的句子集是与根非终结词匹配的句子集，称为`root`或`start`。但在程序中，我们会用更好记的名字如`url`、`html`或`markdown`。

### 语法运算符

生产表达式中最重要的三个运算符是：

* 连接（concatenation）
* 重复（repetition）
* 并集（union，also called alternation）

还有其他运算符，但这些只是语法糖（上述三种运算的组合）：

* 可选（option，0 or 1 occurrence）
* 多次重复（1+ repetition，1 or more occurrences）
* 字符类（character classes）
* 使用括号进行分组（grouping using parentheses）

### 例子：URL

假设我们想编写一个表示 URL 的语法。让我们从简单的例子开始，逐步建立语法，并随着我们的进行扩展语法。

下面是一个简单的 URL：

```java
http://mit.edu/
```

表示仅包含此 URL 的句子集的语法如下所示：

```java
url ::= 'http://mit.edu/'
```

但是，让我们将其推广到其他域中：

```java
http://stanford.edu/
http://google.com/
```

我们可以把它写成一行，像这样：

```java
url ::= 'http://' [a-z]+ '.' [a-z]+  '/'
```

<img src="C:\Users\Yiming\Documents\课程相关\自学\assets\url-simple.png" alt="通过用单行 URL 语法解析 'http://mit.edu' 生成的解析树" style="zoom: 50%;" />

此语法表示仅由两部分主机名组成的所有 URL 的集合，其中主机名的每一部分由 1 个或多个字母组成。所以`http://mit.edu/`和`http://yahoo.com/`会匹配，但`http://ou812.com/`却不会。

在这种单行形式中，对于单个非终端，其生产仅使用运算符和终端，语法称为**正则表达式**（稍后会详细介绍）。但是，如果我们使用新的非终端来命名这些部件，则更容易理解：

```java
url ::= 'http://' hostname '/'
hostname ::= word '.' word
word ::= [a-z]+
```

<img src="C:\Users\Yiming\Documents\课程相关\自学\assets\url-with-hostname.png" alt="通过使用 URL、hostname 和 word nonterminal 的语法解析 'http://mit.edu' 生成的解析树" style="zoom:50%;" />

此语法的解析树现在显示在上面。这棵树现在有更多的结构。树的叶子是字符串中已解析的部分。如果我们把叶子连接在一起，我们将恢复原始字符串。

我们还需要如何概括？主机名可以有两个以上的组件，并且可以有一个可选的端口号：

```java
http://didit.csail.mit.edu:4949/
```

为了处理这种字符串，语法现在是：

```java
url ::= 'http://' hostname (':' port)? '/' 
hostname ::= word '.' hostname | word '.' word
port ::= [0-9]+
word ::= [a-z]+
```

<img src="C:\Users\Yiming\Documents\课程相关\自学\assets\url-with-recursive-hostname.png" alt="通过使用具有递归主机名规则的语法解析“http://mit.edu”生成的解析树" style="zoom:50%;" />

*请注意，主机名现在是如何根据自身递归方式定义的。* 主机名定义的哪一部分是基本情况，哪一部分是递归步骤？允许使用哪些类型的主机名？

使用重复运算符，我们也可以像这样编写主机名：

```java
hostname ::= (word '.')+ word
```

要注意的另一件事是，此语法允许使用技术上不合法的端口号，因为端口号的范围只能从 0 到 65535。我们可以编写一个更复杂的端口定义，只允许这些整数，但这通常不会在语法中完成。相反，约束 0 <= 端口 <= 65535 将与语法一起指定。

为了走得更远，我们应该做更多的事情：

- 泛化`http`以支持 URL 可以具有的其他协议
- 将末尾的`/`概括为斜杠分隔的路径
- 允许主机名使用完整的合法字符集，而不仅仅是 A-Z

### 例子：Markdown 和 HTML

现在让我们看一下某些文件格式的语法。我们将使用两种不同的标记语言来表示文本中的排版样式。他们来了：

**Markdown**

```markdown
This is _italic_.
```

**HTML**

```html
Here is an <i>italic</i> word.
```

为简单起见，我们的示例 HTML 和 Markdown 语法将仅指定斜体，但当然可以使用其他文本样式。

以下是 Markdown 简化版本的语法：

```java
markdown ::=  ( normal | italic ) *
italic ::= '_' normal '_'
normal ::= text
text ::= [^_]*
```

<img src="C:\Users\Yiming\Documents\课程相关\自学\assets\markdown.png" alt="由 Markdown 语法生成的解析树" style="zoom:50%;" />

以下是我们简化的 HTML 版本的语法：

```java
html ::=  ( normal | italic ) *
italic ::= '<i>' html '</i>'
normal ::= text
text ::= [^<>]*
```

<img src="C:\Users\Yiming\Documents\课程相关\自学\assets\html.png" alt="由 HTML 语法生成的解析树" style="zoom:50%;" />

## 正则表达式

**正则**语法有一个特殊属性：通过将每个非端点（根除外）替换为其右侧，您可以将其减少为根的单个产生式，只有端点和运算符位于右侧。

我们的URL语法是正则的。通过将非端点替换为其产生式，可以将其简化为单个表达式：

```java
url ::= 'http://' ([a-z]+ '.')+ [a-z]+ (':' [0-9]+)? '/' 
```

Markdown语法也是正则的：

```java
markdown ::= ([^_]* | '_' [^_]* '_' )*
```

但是我们的 HTML 语法不能完全简化。通过用右边代替非端点，你最终可以把它减少到这样的东西：

```java
html ::=  ( [^<>]* | '<i>' html '</i>' ) *
```

但是右边的递归使用`html`不能消除，也不能简单地用重复运算符替换。所以HTML语法是不正则的。

端点和运算发的简化表达式可以写成更紧凑的形式，称为正则表达式。正则表达式取消了端点周围的引号以及端点和运算符之间的空格，因此它仅由端点字符、用于分组的括号和运算符字符组成。例如，我们的`markdown`格式的正则表达式只是：

```java
([^_]*|_[^_]*_)*
```

正则表达式（regular expressions）也简称为正则式（regexes）。正则表达式的可读性远不如原始语法，因为它缺少记录每个子表达式含义的非端点名称。 但是正则表达式的实现速度很快，并且许多编程语言中都有支持正则表达式的库。

除了我们上面在语法中使用的那些之外，通常在编程语言库中实现的正则表达式语法还有一些更特殊的运算符。 以下是一些常见有用的方法：

```java
.       any single character

\d      any digit, same as [0-9]
\s      any whitespace character, including space, tab, newline
\w      any word character, including letters and digits

\., \(, \), \*, \+, ...
        escapes an operator or special character so that it matches literally
```

每当存在会与特殊字符混淆的端点字符时，使用反斜杠就很重要。因为我们的`url`正则表达式在其中有`.`作为端点，所以我们需要使用反斜杠来转义它：

```java
http://([a-z]+\.)+[a-z]+(:[0-9]+)/
```

### 在 Java 中使用正则表达式

在 Java 中，您可以使用正则表达式来操作字符串（请参阅 [`String.split`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-)，[`String.matches`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#matches-java.lang.String-)，[`java.util.regex.Pattern`](https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html)）。它们是作为现代脚本语言（如 Python、Ruby 和 Javascript）的一流功能内置的，您可以在许多文本编辑器中使用它们来查找和替换。正则表达式是你的朋友！大多数时候。以下是一些示例。

将所有空格替换为单个空格：

```java
String singleSpacedString = string.replaceAll(" +", " ");
```

匹配 URL：

```java
Pattern regex = Pattern.compile("http://([a-z]+\\.)+[a-z]+(:[0-9]+)?/");
Matcher m = regex.matcher(string);
if (m.matches()) {
    // then string is a url
}
```

提取 HTML 标记的一部分：

```java
Pattern regex = Pattern.compile("<a href=['\"]([^']*)['\"]>");
Matcher m = regex.matcher(string);
if (m.matches()) {
    String url = m.group(1); 
    // Matcher.group(n) returns the nth parenthesized part of the regex
}
```

请注意 URL 和 HTML 标记示例中的反斜杠（backslashes）。 在 URL 示例中，我们想要匹配一个文字句点（literal period）`.`，因此我们必须首先对其进行转义为`\.`，以防止它被解释为正则表达式匹配任意字符运算符，然后我们必须进一步转义它为`\\.`，以保护反斜杠不被解释为 Java 字符串转义字符。在 HTML 示例中，我们必须对引号进行转义，由`"`变为`\"`，以防止它结束字符串。 反斜杠转义的频率使得正则表达式的可读性更差。

### 上下文无关语法

一般来说，可以用我们的语法系统表达的语言被称为无上下文。并非所有的上下文无关语言都是常规的;也就是说，某些语法不能简化为单个非递归生成。我们的 HTML 语法是与上下文无关的，但不是正则的。

大多数编程语言的语法也是与上下文无关的。通常，任何具有嵌套结构的语言（如嵌套括号或大括号）都是与上下文无关的，但不是正则的。该描述适用于 Java 语法，此处部分显示：

```java
statement ::= 
  '{' statement* '}'
| 'if' '(' expression ')' statement ('else' statement)?
| 'for' '(' forinit? ';' expression? ';' forupdate? ')' statement
| 'while' '(' expression ')' statement
| 'do' statement 'while' '(' expression ')' ';'
| 'try' '{' statement* '}' ( catches | catches? 'finally' '{' statement* '}' )
| 'switch' '(' expression ')' '{' switchgroups '}'
| 'synchronized' '(' expression ')' '{' statement* '}'
| 'return' expression? ';'
| 'throw' expression ';' 
| 'break' identifier? ';'
| 'continue' identifier? ';'
| expression ';' 
| identifier ':' statement
| ';'
```

# Reading 18: Parser Generators（解析生成器）

略

# Reading 19: Concurrency（并发）

## 并发

**并发**意味着多个计算同时发生。并发在现代编程中无处不在，无论我们喜欢与否：

* 网络中的多台计算机
* 在一台计算机上运行多个应用程序
* 计算机中的多个处理器（如今，通常是在单个芯片上有多个处理器内核）

事实上，并发在现代编程中是必不可少的：

* 网站必须同时处理多个用户
* 移动应用程序需要在服务器上（云端）进行一些处理
* 图形用户界面几乎总是需要不打断用户的后台工作。例如，Eclipse 会在您编辑 Java 代码时对其进行编译。

能够使用并发进行编程在未来任然很重要。处理器时钟速度不再增加。相反的，我们在每一代芯片上都获得了更多的内核。因此，在未来，为了让计算运行得更快，我们必须将计算分成并发得部分。

## 两种并发编程模型

并发编程有两种常见的模型：**共享内存**和**消息传递**。

**共享内存。** 在并发的共享内存模型中，并发模块通过在内存中读取和写入共享对象进行交互。

<img src="C:\Users\Yiming\Documents\课程相关\自学\assets\shared-memory.png" alt="共享内存" style="zoom: 33%;" />

共享内存模型的示例：

- A 和 B 可能是同一台计算机中的两个处理器（或处理器核心），共享相同的物理内存。
- A 和 B 可能是在同一台计算机上运行的两个程序，它们共享一个公共文件系统，其中包含可以读取和写入的文件。
- A 和 B 可能是同一个 Java 程序中的两个线程（我们将在下面解释线程是什么），共享相同的 Java 对象。

**消息传递。** 在消息传递模型中，并发模块通过通信通道相互发送消息进行交互。模块发送消息，每个模块的传入消息都排队等待处理。示例包括：

<img src="C:\Users\Yiming\Documents\课程相关\自学\assets\message-passing.png" alt="消息传递" style="zoom: 33%;" />

- A 和 B 可能是网络中的两台计算机，通过网络连接进行通信。
- A 和 B 可能是 Web 浏览器和 Web 服务器 – A 打开与 B 的连接并请求网页，B 将网页数据发送回 A。
- A 和 B 可能是即时消息客户端和服务器。
- A 和 B 可能是在同一台计算机上运行的两个程序，其输入和输出通过管道连接，就像在命令提示符中键入`ls | grep`一样。

## 进程（Processes）、线程（Threads）、时间片（Time-slicing）

消息传递模型和共享内存模型是关于并发模块如何通信的。并发模块本身有两种不同的类型：进程和线程。

**进程**。进程是与同一台计算机上的其他进程**隔离**的正在运行的程序的实例。特别是，它有自己的机器内存的私有部分。

进程抽象是一台**虚拟计算机**。它使程序感觉像是它拥有了整个机器 - 就像创建了一台新的计算机，具有新的内存，只是为了运行该程序。

就像通过网络连接的计算机一样，进程之间通常不共享内存。一个进程根本无法访问另一个进程的内存或对象。在大多数操作系统上，在进程之间共享内存是*可能的*，但这需要特别努力。相比之下，一个新进程会自动准备好进行消息传递，因为它是使用标准的输入和输出流创建的，这些输入和输出流是您在 Java 中使用的`System.out`和`System.in`流。

**线程**。线程是正在运行的程序内部的控制点。可以将其视为程序中正在运行的某个位置，以及指向该位置的方法调用堆栈（因此线程在到达`return`语句时可以返回堆栈）。

正如进程代表虚拟计算机一样，线程抽象代表虚拟**处理器**。创建新线程模拟在进程表示的虚拟计算机内创建新处理器。这个新的虚拟处理器运行相同的程序，并与进程中的其他线程共享相同的内存。

线程会自动准备好共享内存，因为线程在进程中共享所有内存。获取单个线程专用的“线程本地”内存需要特别努力。此外，还需要通过创建和使用队列数据结构来显式设置消息传递。我们将在以后的阅读中讨论如何做到这一点。

我的计算机中如何能有许多只有一个或两个处理器的并发线程？当线程数多于处理器数时，并发性通过**时间切片** 进行模拟，这意味着处理器在线程之间切换。右图显示了在只有两个实际处理器的计算机上如何对三个线程 T1、T2 和 T3 进行时间切片。在图中，时间向下进行，因此首先一个处理器运行线程 T1，另一个处理器运行线程 T2，然后第二个处理器切换到运行线程 T3。线程 T2 只是暂停，直到同一处理器或另一个处理器上的下一个时间片。

<img src="C:\Users\Yiming\Documents\课程相关\自学\assets\time-slicing.png" alt="时间切片" style="zoom: 33%;" />

在大多数系统上，时间切片是不可预测和不确定的，这意味着线程可能随时暂停或恢复。

## Java 中的线程

创建`Thead`实例的应用程序必须提供将在该线程中运行的代码。有两种方法可以执行此操作：

提供一个`Runnable`对象。`Runnable`接口定义了一个`run`方法，它包含了在线程中要运行的代码。`Runnable`对象被传递给`Thread`构造函数。下面是一个例子：

```java
public class HelloRunnable implements Runnable {

    public void run() {
        System.out.println("Hello from a thread!");
    }

    public static void main(String args[]) {
        (new Thread(new HelloRunnable())).start();
    }

}
```

~~`Thread`子类。`Thread`类自己实现了`Runnable`，但`run`方法却没有做任何事情。一个应用可以实现`Thread`子类，然后自己重写`run`方法。下面是一个例子：~~

```java
public class HelloThread extends Thread {

    public void run() {
        System.out.println("Hello from a thread!");
    }

    public static void main(String args[]) {
        (new HelloThread()).start();
    }

}
```

* 永远不要用第二种方法（即创建`Thread`子类）
* 总是实现`Runnable`接口，然后使用`new Thead(..)`构造函数

按照第一种方法的示例，该类实现了`Runnable`：

```java
public class HelloRunnable implements Runnable {
    public void run() {
        System.out.println("Hello from a thread!");
    }
}
// ... in the main method:
new Thread(new HelloRunnable()).start();
```

一种常见的方式是使用匿名函数启动一个线程，这样就消除了`Runnable`命名的类：

```java
new Thread(new Runnable() {
    public void run() {
        System.out.println("Hello from a thread!");
    }
}).start();
```

## 共享内存（Shared Memory Example）示例

让我们看一个共享内存系统的示例。这个例子的重点是表明并发编程是困难的，因为它可能有细微的错误。

想象一下，一家银行的自动取款机使用共享内存模型，因此所有自动取款机都可以在内存中读取和写入相同的账户对象。

<img src="C:\Users\Yiming\Documents\课程相关\自学\assets\shared-memory-bank-account.png" alt="银行账户的共享内存模型" style="zoom:50%;" />

为了说明可能出错的地方，让我们将银行简化为一个账户，在`balance`变量中存储一美元余额，以及两个操作`deposit`和`withdraw`，只需添加或删除一美元：

```java
// suppose all the cash machines share a single bank account
private static int balance = 0;

private static void deposit() {
    balance = balance + 1;
}
private static void withdraw() {
    balance = balance - 1;
}
```

过程不多解释，这里是著名的争用条件过程了。

一个想法是使用一个循环来持续检查并发条件，这被称为忙等待（busy waiting）。这不是一个好的模式。

```java
private boolean ready = false;
private int answer = 0;

// computeAnswer runs in one thread
private void computeAnswer() {
    answer = 42;
    ready = true;
}

// useAnswer runs in a different thread
private void useAnswer() {
    while (!ready) {
        Thread.yield();
    }
    if (answer == 0) throw new RuntimeException("answer wasn't ready!");
}
```

看似结果会是正确的。问题在于，现代编译器和处理器做了很多事情来使代码更快。其中一件事是在更快的存储（处理器上的寄存器或缓存）中临时复制 answer 和 ready 等变量，并暂时处理它们，然后最终将它们存储回内存中的官方位置。

## 消息传递（Message Passing）示例

让我们看一下银行帐户示例的消息传递方法。

现在，不仅自动取款机是模块，账户也是模块。模块通过相互发送消息进行交互。传入的请求被放置在队列中，一次处理一个。发件人在等待其请求的答复时不会停止工作。它处理来自自己队列的更多请求。对其请求的回复最终以另一条消息的形式返回。

遗憾的是，消息传递并不能消除争用条件的可能性。假设每个账户都支持`get-balance`和`withdraw`操作，并带有相应的消息。自动取款机 A 和 B 的两个用户都试图从同一个账户中提取一美元。他们首先检查余额，以确保他们提取的金额永远不会超过账户保留的金额，因为透支会引发大额银行罚款：

```java
get-balance
if balance >= 1 then withdraw 1
```

<img src="C:\Users\Yiming\Documents\课程相关\自学\assets\message-passing-bank-account.png" alt="消息传递银行帐户示例" style="zoom: 50%;" />

问题再次是交错，但这次交错发送到银行账户的消息，而不是 A 和 B 执行的指令。如果账户开始时有一美元，那么什么消息的交错会让 A 和 B 误以为他们都可以提取一美元，从而透支账户？

这里的一个教训是，您需要仔细选择消息传递模型的操作。 `withdraw-if-sufficient-funds`将是比`withdraw`更好的操作。

## 并发性难以测试和调试

并发 bug 表现出非常差的可重现性。让它们以同样的方式发生两次是很困难的。指令或消息的交错取决于受环境强烈影响的事件的相对时间。延迟可能是由其他正在运行的程序、其他网络流量、操作系统调度决策、处理器时钟速度的变化等引起的。每次运行包含争用条件的程序时，可能会得到不同的行为。

这些类型的 bug 是**海森堡（heisen）bug** ，它们是不确定的且难以复制的，而不是**玻尔（bohr）bug** ，每当您查看它时，它都会反复出现。顺序编程中几乎所有的 bug 都是玻尔bug。

当你试图用`println`或者`debugger`查看它时，海森堡 bug 甚至可能消失！原因是打印和调试比其他操作慢得多，通常慢 100-1000 倍，以至于它们极大地改变了操作的时间和交错。因此，在cashMachine（）中插入一个简单的打印语句：

```java
private static void cashMachine() {
    for (int i = 0; i < TRANSACTIONS_PER_MACHINE; ++i) {
        deposit(); // put a dollar in
        withdraw(); // take it back out
        System.out.println(balance); // makes the bug disappear!
    }
}
```

…突然间，余额总是为 0，如愿以偿，错误似乎消失了。但它只是被掩盖了，并没有真正修复。程序中其他位置的时间更改可能会突然使 bug 再次出现。

# Reading 20: Thead Safety（线程安全）

基本上有四种方法可以使共享内存并发中的变量访问安全：

- **封闭性（Confinement）**。不要在线程之间共享变量。这个想法被称为限制，我们今天将探讨它。
- **不变性（Immutability）**。使共享数据不可变。我们已经讨论了很多关于不变性的问题，但是我们将在本文中讨论并发编程的一些额外约束。
- **线程安全数据类型（Threadsafe data type）**。将共享数据封装在现有的 threadsafe 数据类型中，以便为您进行协调。我们今天就来讲这个。
- **同步（Synchronization）**。使用同步可防止线程同时访问变量。同步是构建自己的线程安全数据类型所必需的。

我们将在本文中讨论前三种方法，以及如何使用这三个想法来论证您的代码是线程安全的。在后面的阅读中，我们将讨论第四种方法，即同步。

## 线程安全意味着什么

如果数据类型或静态方法在从多个线程使用时行为正确，则无论这些线程是如何执行的，并且不需要调用代码的额外协调，那么它是**线程安全**的。

* 行为正确，意味着满足其规格并保持其表示不变性；
* 无论线程如何执行，意味着线程可能位于多个处理器上，或者在同一个处理器上进行时间分割；
* 没有额外的协调，意味着数据类型不能为其调用者设置与时间相关的先决条件。

类似迭代器，它不是线程安全的。`Iterator`的规范规定，不能在迭代集合的同时修改它。

## 策略1：封闭性

线程限制是一个简单的想法：通过将数据限制在单个线程中，可以避免对可变数据的争用。不要赋予任何其他线程直接读取或写入数据的能力。

由于共享可变数据是竞争条件的根本原因，因此限制通过**不共享**可变数据来解决它。

局部变量始终受线程限制。一个局部变量存储在堆栈中，每个线程都有自己的堆栈。

要小心，变量是线程限制的，但如果它是一个对象引用，你还需要检查它指向的对象。如果对象是可变的，那么我们要检查对象是否也被限制 - 不能有可从任何其他线程访问到的对它的引用。

限制是使代码中`n`、`i`和`result`的安全访问的原因，如下图所示：

```java
public class Factorial {

    /**
     * Computes n! and prints it on standard output.
     * @param n must be >= 0
     */
    private static void computeFact(final int n) {
        BigInteger result = new BigInteger("1");
        for (int i = 1; i <= n; ++i) {
            System.out.println("working on fact " + n);
            result = result.multiply(new BigInteger(String.valueOf(i)));
        }
        System.out.println("fact(" + n + ") = " + result);
    }

    public static void main(String[] args) {
        new Thread(new Runnable() { // create a thread using an
            public void run() {     // anonymous Runnable
                computeFact(99);
            }
        }).start();
        computeFact(100);
    }
}
```

这段代码是以一个匿名的`Runnable`开始线程`computeFact(99)`。

虽然两个线程中都有`n`、`i`和`result`三个变量，但是由于它们是被调用函数的局部变量，因此互相之间并无关系。这就是成功的将数据封闭在了各自的线程中。

### 避免全局变量

与局部变量不同，静态变量不会自动受到线程限制。

如果你的程序中有静态变量，那么你必须提出一个论点，即只有一个线程会使用它们，并且你必须清楚地记录这个事实。更好的是，您应该完全消除静态变量。

下面是一个示例：

```java
// This class has a race condition in it.
public class PinballSimulator {

    private static PinballSimulator simulator = null;
    // invariant: there should never be more than one PinballSimulator
    //            object created

    private PinballSimulator() {
        System.out.println("created a PinballSimulator object");
    }

    // factory method that returns the sole PinballSimulator object,
    // creating it if it doesn't exist
    public static PinballSimulator getInstance() {
        if (simulator == null) {
            simulator = new PinballSimulator();
        }
        return simulator;
    }
}
```

这个类在`getInstance()`方法中有一个争用——两个线程可以同时调用它，并最终创建`PinballSimulator`对象的两个副本，这是我们不想要的。

要使用线程限制方法修复此争用，您需要指定只允许某个线程（可能是“弹球模拟线程”）调用`PinballSimulator.getInstance()`。这里的风险是 Java 无法帮助您保证这一点。

一般来说，静态变量对于并发性来说是非常危险的。他们可能隐藏在一个似乎没有副作用或突变的无害功能后面。请看这个例子：

```java
// is this method threadsafe?
/**
 * @param x integer to test for primeness; requires x > 1
 * @return true if x is prime with high probability
 */
public static boolean isPrime(int x) {
    if (cache.containsKey(x)) return cache.get(x);
    boolean answer = BigInteger.valueOf(x).isProbablePrime(100);
    cache.put(x, answer);
    return answer;
}

private static Map<Integer,Boolean> cache = new HashMap<>();
```

此功能会存储以前呼叫的答案，以防再次请求。这种技术被称为记忆化，它是对慢函数（如精确素数检验）的明智优化。但该方法从多个线程调用是不安全的，原因是静态变量`cache`被所有调用`isPrime()`的地方访问，而`cache`作为`HashMap`，不是线程安全的。

## 策略2：不变性

实现线程安全的第二种方法是使用不可变的引用和数据类型。不可变性解决了竞争条件的共享可变数据原因，并简单地通过使共享数据**不可变**来解决它。

final 变量是不可变的引用，因此声明为 final 的变量可以安全地从多个线程访问。您只能读取变量，而不能写入变量。要小心，因为这种安全性只适用于变量本身，我们仍然必须论证变量指向的对象是不可变的。

不可变对象通常也是线程安全的。我们在这里说“通常”，因为我们目前对不可变性的定义对于并发编程来说太宽松了。我们已经说过，如果类型的对象在其整个生命周期中始终表示相同的抽象值，那么该类型是不可变的。但这实际上允许该类型自由地改变其代表，只要这些突变对客户来说是不可见的。

我们看到这个概念的一个例子，称为 benevolent（仁慈）或 beneficent mutation（仁慈突变），例如当我们看到一个不可变列表时，它在客户端第一次请求长度时将其长度缓存在可变字段中。缓存是一种典型的有益突变。

但是，对于并发性来说，这种隐藏的突变并不安全。使用有益突变的不可变数据类型必须使用锁（与可变数据类型所需的技术相同）使自身线程安全，我们将在以后的阅读中讨论。

### 更强的不变性定义

因此，为了确信不可变数据类型在没有锁的情况下是线程安全的，我们需要对不可变性有一个更强的定义：

- 无 mutator 方法
- 所有字段都是私有的和最终的
- 无表示泄露
- REP 中没有任何可变对象的突变 - 甚至没有有益的突变

如果您遵循这些规则，那么您可以确信您的不可变类型也将是线程安全的。

## 策略 3：使用线程安全数据类型

我们实现线程安全的第三个主要策略是在现有的线程安全数据类型中存储共享的可变数据。

当 Java 库中的数据类型是线程安全的时，其文档将明确说明这一事实。例如，下面是 [StringBuffer ](https://docs.oracle.com/javase/8/docs/api/?java/lang/StringBuffer.html)所说的：

> [StringBuffer 是]线程安全、可变的字符序列。字符串缓冲区类似于 String，但可以修改。在任何时间点，它都包含一些特定的字符序列，但是可以通过某些方法调用来更改序列的长度和内容。
>
> 字符串缓冲区可以安全地供多个线程使用。这些方法在必要时进行同步，以便任何特定实例上的所有操作都按照某种串行顺序发生，该顺序与所涉及的每个单个线程执行的方法调用的顺序一致。

这与 [StringBuilder ](https://docs.oracle.com/javase/8/docs/api/?java/lang/StringBuilder.html)形成鲜明对比：

> [StringBuilder 是]可变的字符序列。此类提供与 StringBuffer 兼容的 API，但不保证同步。此类设计为在字符串缓冲区由单个线程使用的地方用作 StringBuffer 的直接替换（通常如此）。在可能的情况下，建议优先使用此类而不是 StringBuffer，因为它在大多数实现下会更快。

在 Java API 中，找到两种执行相同操作的可变数据类型已经变得很常见，一种是线程安全的，另一种不是。原因就是这句话所表明的：与不安全的类型相比，线程安全的数据类型通常会导致性能损失。

非常不幸的是，`StringBuffer`和`StringBuilder`的名字如此相似，而名称中没有任何迹象表明线程安全是它们之间的关键区别。同样不幸的是，它们不共享一个通用的接口，所以当你需要线程安全时，你不能简单地将一个实现换成另一个实现。Java 集合接口在这方面做得更好，我们接下来将看到。

### 线程安全集合

Java 中的集合接口`List`、`Set`和`Map`具有非线程安全的基本实现。目前已经习惯使用的这些实现，即`ArrayList`、`HashMap`和`HashSet`都不能在多个线程中安全地使用。

幸运地是，就像`Collections`的 API 提供了使集合不可变的包装器方法一样，它提供了另一组包装器方法来使集合线程安全，同时仍然是可变的。

这些包装器有效地使集合的每种方法相对于其他方法都是原子的。 **原子操作**实际上是一次性发生的 - 它不会将其内部操作与其他操作的操作交错，并且在整个操作完成之前，其他线程都不会看到该操作的任何效果，因此它看起来永远不会部分完成。

现在，我们来看一种修复我们刚才见到的`isPrime()`方法：

```java
private static Map<Integer,Boolean> cache =
                Collections.synchronizedMap(new HashMap<>());
```

有几点要注意：

**不要绕过包装器。** 确保丢弃对底层非线程安全集合的引用，并且仅通过同步包装器访问它。这在上面的代码行中会自动发生，因为新的`HashMap`只会传递给`synchronizedMap()`，而永远不会存储在其他任何地方。（我们在不可修改的包装器中看到了同样的警告：底层集合仍然是可变的，引用它的代码可以规避不变性。）

**迭代器仍然不是线程安全的。** 尽管对集合本身（ `get()`、`put()`、`add()`等）的方法调用现在是线程安全的，但从集合创建的迭代器仍然不是线程安全的。所以你不能使用`iterator()`，或者 for 循环语法：

```java
for (String s: lst) { ... } // not threadsafe, even if lst is a synchronized list wrapper
```

这个迭代问题的解决方案是在需要迭代集合时获取集合的锁，我们将在以后的阅读中讨论这一点。

最后， **原子操作不足以防止争用：**使用同步集合的方式仍可能具有争用条件。考虑以下代码，它检查列表是否至少有一个元素，然后获取该元素：

```java
if ( ! lst.isEmpty()) { String s = lst.get(0); ... }
```

即使您将`List`转变为同步列表，此代码仍可能具有争用条件，因为另一个线程可能会在调用`isEmpty()`和调用`get()`之间删除元素。

因此`isPrime()`方法依然存在潜在的竞争：

```java
if (cache.containsKey(x)) return cache.get(x);
boolean answer = BigInteger.valueOf(x).isProbablePrime(100);
cache.put(x, answer);
```

同步的映射确保`containsKey()`、`get()`和`put()`现在是原子的，因此从多个线程使用它们不会损坏映射的 rep 不变性。但是这三个操作现在可以以任意方式相互交错，这可能会破坏缓存中需要的不变量`isPrime`：如果缓存将整数 *x* 映射到值 *f* ，则当且仅当 *f* 为真时，*x* 是素数。如果缓存未能满足这种不变性，那么我们可能会返回错误的结果。

因此，我们不得不争辩说，`containsKey()`、`get()`和`put()`之间的竞赛不会威胁到这种不变性。

1. `containsKey()`和`get()`之间的争用是无害的，因为我们从不从缓存中删除项目。一旦它包含 x 的结果，它将继续这样做。
2. `containsKey()`和`put()`之间存在着争用。因此，最终可能会出现两个线程同时测试同一 x 的素数，并且两个线程都会争先恐后地调用`put()`。但是他们俩都应该以相同的答案调用`put()`，所以谁赢得比赛并不重要——结果会是一样的。

即使你使用的是线程安全数据类型，也需要对安全性进行这些谨慎的论证，这是并发性困难的主要原因。

## 如何做安全性的论证

并发性很难测试或调试。因此，如果想让别人相信你的并发程序是对的，最好的方法就是明确的证明它没有争用，并把它写下来。

安全性论证需要对模块或程序中存在的所有线程以及它们使用的数据进行编排，并论证正在使用四种技术的哪一种来防止每个数据对象或变量的争用：封闭性、不变性、线程安全数据类型或同步。当你使用最后两个时，需要对数据的访问都是适当的原子性做证明，即所依赖的不变量不会收到交错访问的风险。上面关于`isPrime`的证明是一个例子。

### 数据类型的线程安全论证

让我们看一些示例，说明如何为数据类型创建线程安全参数。请记住我们的四种线程安全方法：限制、不可变性、线程安全数据类型和同步。由于我们在本文中没有讨论同步，因此我们将只关注前三种方法。

当我们只对数据类型进行争论时，限制通常不是一种选择，因为您必须知道系统中存在哪些线程以及它们被授予了哪些对象的访问权限。如果数据类型创建了自己的线程集，那么您可以谈论与这些线程相关的限制。否则，线程是从外部传入的，承载客户端调用，并且数据类型可能无法保证哪些线程引用了哪些内容。因此，在这种情况下，限制不是一个有用的论点。通常，我们在更高层次上使用限制，将系统作为一个整体来讨论，并争论为什么我们不需要为我们的某些模块或数据类型提供线程安全，因为它们在设计上不会在线程之间共享。

不变性通常是一个有用的论点：

```java
/** MyString is an immutable data type representing a string of characters. */
public class MyString {
    private final char[] a;
    // Thread safety argument:
    //    This class is threadsafe because it's immutable:
    //    - a is final
    //    - a points to a mutable char array, but that array is encapsulated
    //      in this object, not shared with any other object or exposed to a
    //      client
```

这是 MyString 的另一个代表，在参数中需要多加注意：

```java
/** MyString is an immutable data type representing a string of characters. */
public class MyString {
    private final char[] a;
    private final int start;
    private final int len;
    // Rep invariant:
    //    0 <= start <= a.length
    //    0 <= len <= a.length-start
    // Abstraction function:
    //    represents the string of characters a[start],...,a[start+length-1]
    // Thread safety argument:
    //    This class is threadsafe because it's immutable:
    //    - a, start, and len are final
    //    - a points to a mutable char array, which may be shared with other
    //      MyString objects, but they never mutate it
    //    - the array is never exposed to a client
```

请注意，由于此`MyString`代表是为在多个`MyString`对象之间共享数组而设计的，因此我们必须确保共享不会威胁到其线程安全。但是，只要它不威胁到`MyString`的不变性，我们就可以确信它不会威胁到线程的安全。

我们还必须避免代表暴露。Rep 暴露对任何数据类型都是不利的，因为它会威胁到数据类型的 rep 不变性。这对线程安全也是致命的。

### 糟糕的安全论证

以下是线程安全的一些不正确的论点：

```java
/** MyStringBuffer is a threadsafe mutable string of characters. */
public class MyStringBuffer {
    private String text;
    // Rep invariant:
    //   none
    // Abstraction function:
    //   represents the sequence text[0],...,text[text.length()-1]
    // Thread safety argument:
    //   text is an immutable (and hence threadsafe) String,
    //   so this object is also threadsafe
```

为什么这个论点行不通？字符串确实是不可变的和线程安全的;但是指向该字符串（特别是`text`变量）的 rep 不是不可变的。`text`不是最终变量，实际上在这种数据类型中它不可能是最终变量，因为我们需要数据类型来支持插入和删除操作。因此，`text`变量本身的读取和写入不是线程安全的。这个论点是错误的。

这是另一些不完善的论点：

```java
public class Graph {
    private final Set<Node> nodes =
                   Collections.synchronizedSet(new HashSet<>());
    private final Map<Node,Set<Node>> edges =
                   Collections.synchronizedMap(new HashMap<>());
    // Rep invariant:
    //    for all x, y such that y is a member of edges.get(x),
    //        x, y are both members of nodes
    // Abstraction function:
    //    represents a directed graph whose nodes are the set of nodes
    //        and whose edges are the set (x,y) such that
    //                         y is a member of edges.get(x)
    // Thread safety argument:
    //    - nodes and edges are final, so those variables are immutable
    //      and threadsafe
    //    - nodes and edges point to threadsafe set and map data types
```

```java
public void addEdge(Node from, Node to) {
    if ( ! edges.containsKey(from)) {
        edges.put(from, Collections.synchronizedSet(new HashSet<>()));
    }
    edges.get(from).add(to);
    nodes.add(from);
    nodes.add(to);
}
```

### 可串行化

即两个线程各自的一系列操作，之前虽然前后互有干扰，但是不影响最后的结果，和各自执行的效果是一样的。
